#+TITLE: Mobile Gallery Gap Investigation
#+DATE: 2025-10-22

* Problem
- On mobile viewports (≤768px) the main gallery still shows intermittent vertical gaps between certain images despite the desired one-photo-per-row layout.
- Reproduced in Safari and Chrome device simulators at ~http://localhost:4321/~ after hard refresh.

* Observations
- First and second photos often display extra white space beneath them, while later items stack flush, suggesting inconsistent inline styles per element.
- DOM inspection shows some anchors retain absolute positioning inline styles (e.g., `top`, `left`) even after switching to the mobile stack.
- Resizing from desktop to mobile and loading directly on mobile both show the issue, implying script logic affects initial render as well.

* Hypotheses
- Debounced resize handler may re-run justified layout after mobile layout applies, reintroducing absolute positioning on select nodes.
- GLightbox initialization might clone nodes and restore previous styles, leaving residual gaps.
- Astro hydration timing could mean the flex stack runs before image load completes, and subsequent layout pass reverts to justified spacing for a subset of images.

* Attempts
1. Lowered justified-layout `boxSpacing` on narrow viewports (2px) to minimize gutters. → No noticeable change; gaps persisted.
2. Added mobile-only branch to bypass justified layout and stack anchors with `flex` container and uniform image dimensions. → Improved consistency but gaps still appear after certain items.
3. Forced container style resets when returning to desktop mode to avoid leftover flex properties. → Desktop fine; mobile gaps remain.

* Status
- Issue unresolved. Need deeper inspection of resize/init order and GLightbox side effects before next iteration.

* Root Cause Analysis (2025-10-22)

** Identified Issues
1. *Breakpoint Mismatch*: Mobile fallback triggers at ≤480px (packeryGallery.ts:44, 70), but gaps appear at ≤768px viewports. Between 481-768px, Packery still runs with absolute positioning.

2. *No Resize Handler for Layout Switching*: Initial layout check happens once in onReady() (line 62). Packery has resize: true (line 84), but no logic exists to switch from Packery → mobile fallback when crossing the breakpoint. When resizing from desktop → tablet → mobile, Packery keeps running until 480px.

3. *Absolute Positioning Persistence*: Packery applies inline styles (position: absolute; left: Xpx; top: Ypx). Mobile fallback tries to reset these (lines 316-334), but lacks !important flags. Race condition: if Packery's resize handler fires after mobile fallback setup, it reapplies absolute positioning.

4. *Multiple Gallery Scripts*: Two gallery implementations found (packeryGallery.ts and photo-grid.ts), both with resize handlers that could conflict.

** Proposed Solution (Robust)
1. Increase mobile breakpoint from 480px → 768px
2. Add resize handler to detect breakpoint crossing and switch layouts
3. Destroy Packery instance before applying mobile fallback
4. Disable Packery's built-in resize (resize: false) and handle manually
5. Debounce resize handler to prevent excessive recalculations

** Alternative Solution (Simple)
1. Increase breakpoint to 768px
2. Add !important flags to all mobile style resets in setupMobileFallback()

** Implementation Plan
- Proceed with robust solution for better maintainability
- Add resize listener that properly destroys/reinits layouts
- Test on physical devices across 480px, 768px, 1024px breakpoints

* ACTUAL Root Cause (2025-10-22) - RESOLVED

** The Real Problem: CSS Specificity War

The JavaScript fixes (resize handler, destroying Packery, !important in JS) were *correct but insufficient*. The fundamental issue was that *CSS was continuously fighting JavaScript*.

*** What Was Actually Happening

1. *Hardcoded CSS rules persisted*:
   - src/pages/index.astro defined `.masonry-item { position: absolute; aspect-ratio: var(--aspect-ratio, 2/3); }`
   - These rules applied at all viewport sizes
   - No media query override existed for mobile

2. *JavaScript couldn't win*:
   - setupMobileFallback() tried: `item.style.position = 'relative'`
   - Even with `.setProperty(..., 'important')` in JS, CSS kept reapplying
   - CSS rules have persistent effect; inline styles are one-time changes

3. *Race condition between CSS and JS*:
   - Page loads → CSS applies absolute positioning
   - JS runs → tries to set relative positioning
   - CSS stays active → gaps remain because aspect-ratio and position persist

*** The Successful Solution

*Added CSS media query with !important flags* in src/pages/index.astro:

```css
@media (max-width: 768px) {
  .masonry-items {
    display: flex !important;
    flex-direction: column !important;
    gap: 8px !important;
  }

  .masonry-item {
    position: relative !important;
    width: 100% !important;
    aspect-ratio: auto !important;
    left: auto !important;
    top: auto !important;
    transform: none !important;
    height: auto !important;
  }

  .masonry-item img {
    width: 100% !important;
    height: auto !important;
    object-fit: contain !important;
  }
}
```

*** Why This Works

- *CSS-level override*: Media query has higher priority than base styles
- *Runs immediately*: No FOUC (Flash Of Unstyled Content) waiting for JS
- *Can't be overridden*: `!important` in media query beats everything
- *Persistent*: Stays active throughout page lifecycle
- *Performant*: Browser handles it natively, no JS overhead

*** Key Debugging Insight

*CSS specificity issues masquerade as JavaScript bugs.* When layout behaves inconsistently:

1. Check CSS rules FIRST (not JavaScript logic)
2. Inspect computed styles in DevTools (not just inline styles)
3. Look for media query gaps (desktop styles bleeding into mobile)
4. Use CSS solutions for CSS problems (don't fight CSS with JS)

The "robust JavaScript solution" was a red herring. The real fix was a simple CSS media query.
