#+TITLE: Codebase Wisdom
#+DATE: 2025-10-03

* 2025-10-22 - CSS Specificity Beats JavaScript Every Time

** Trigger
Mobile gallery showed persistent gaps between images despite extensive JavaScript fixes (resize handlers, destroying Packery, `!important` in inline styles). Spent hours debugging JavaScript logic when the real issue was CSS.

** Mechanism
CSS rules are *persistent and continuously applied*. JavaScript inline styles are *one-time modifications*. When base CSS defines layout properties without media query overrides:

1. CSS applies rules: `.masonry-item { position: absolute; aspect-ratio: 2/3; }`
2. JavaScript tries to override: `item.style.position = 'relative'`
3. CSS continues to apply its rules throughout page lifecycle
4. Result: CSS wins, gaps remain

Even `element.style.setProperty('position', 'relative', 'important')` in JavaScript can't reliably beat CSS because:
- CSS rules reapply on every render/reflow
- Inline styles are snapshots at execution time
- Browser may prioritize CSS cascade over inline styles in some contexts

** The Real Problem
The codebase had:
- Desktop CSS: `.masonry-item { position: absolute; aspect-ratio: var(--aspect-ratio, 2/3); }`
- Mobile JavaScript: tries to set `position: relative`, `aspect-ratio: auto`
- No CSS media query to override at mobile breakpoint

This created a *specificity war* where JavaScript fought CSS and lost.

** Actionable Insight
*Responsive layout changes belong in CSS media queries, not JavaScript.*

When debugging layout issues:
1. *Check CSS first* - Open DevTools → Computed styles, not just inline styles
2. *Look for missing media queries* - Desktop styles bleeding into mobile/tablet
3. *Use CSS solutions for CSS problems* - Don't try to override CSS with JS
4. *Test with CSS disabled* - Does JS alone fix it? If no, it's a CSS issue

** The Fix
Added CSS media query in `src/pages/index.astro`:

```css
@media (max-width: 768px) {
  .masonry-item {
    position: relative !important;
    aspect-ratio: auto !important;
    width: 100% !important;
    /* ... more overrides ... */
  }
}
```

Result: Instant fix. No JavaScript changes needed beyond the media query.

** Pattern for Future Development
When implementing responsive layouts:
1. Define base desktop styles
2. *Immediately add mobile media query overrides* (don't wait for bugs)
3. Use `!important` judiciously in media queries when fighting specificity
4. Test at all breakpoints before considering the feature "done"

JavaScript should *enhance* CSS layouts, not fight them. If you're destroying DOM nodes or battling inline styles, you're solving the wrong problem.

* 2025-10-03 - Vite Module Imports & Masonry Visibility
- The masonry gallery script was initially imported via a relative path such as ~../scripts/packeryGallery.ts~ inside a regular ~<script type="module">~ block. In Astro + Vite, that executes on the client without bundling, so the browser requested ~/src/scripts/packeryGallery.ts~ and received a 404.
- Because the initializer never ran, masonry items kept their absolute positioning and zero-opacity state, resulting in a blank photo grid—especially visible on mobile where the fallback relies entirely on the script.
- Fix: Switch to a hoisted script (~<script hoist>~) so Astro registers the dependency at build time; relative imports like ~import initPackeryGallery from '../scripts/packeryGallery.ts'~ now bundle correctly for every page.
- Reminder: avoid ~Astro.resolve~ for browser-targeted helpers; it runs during SSR and returns plain URLs that bypass Vite's bundler pipeline.
- Checklist update: before shipping a new browser-side helper, confirm the entry point uses ~<script hoist>~ (or a frontmatter import) and that a quick ~npm run build~ succeeds without 404s in devtools logs.

* 2025-10-05 - Masonry Gutters & Edge Balance
- Packery is happiest when column math stays at the canonical 320px + 8px gutter; pushing columns wider without recalculating heights produces the infamous cropped foreheads.
- To get a near edge-to-edge feel without touching Packery internals, wrap the gallery in a ~clamp~-based horizontal padding (see ~.portfolio-wrap~ in ~src/pages/index.astro~). Tuning the clamp keeps large monitors almost full-bleed while still guarding tablets from edge collisions.
- If you *must* widen columns, collect the real aspect ratios (e.g., ahead-of-time via ~sharp~) and set explicit heights before Packery runs, otherwise the forced ~object-fit: cover~ spills important framing.
- Quick test: after tweaking gutters, run ~npm run build~ and flick through the homepage with devtools device toolbar to ensure stacked pairs still align and no gaps appear.

* 2025-10-03 - Mobile Masonry Gaps
- Desktop Packery styles fix explicit heights on `.masonry-item` and images using `!important`. When we flip to the mobile flex fallback, those declarations persisted, so cards kept the desktop height even though the images were set to `auto`, leaving huge blank bands after the visible crop.
- Fix: in the mobile fallback branch (`setupMobileFallback`), explicitly set both the item and `<img>` height via `style.setProperty('height', 'auto', 'important')` and `object-fit: contain` to override the desktop rules with matching specificity.
- Lesson: whenever desktop CSS uses `!important` for layout control, the mobile escape hatch must either remove those classes or override with equal specificity/importance; otherwise expect leftover whitespace or clipping.
- Bonus: Draggabilly is now lazy-loaded through `await import('draggabilly')` inside the helper—pattern to follow for other admin-only libraries.
