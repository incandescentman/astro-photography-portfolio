---
import fs from 'fs';
import path from 'path';
import { Image } from 'astro:assets';
import MainLayout from '../../layouts/MainLayout.astro';
import PhotoComments from '../../components/PhotoComments.astro';

const { folder } = Astro.params;

// Handle nested folder paths (e.g., "red-carpet/tiff")
const folderPath = Array.isArray(folder) ? folder.join('/') : folder;
const photosDir = path.join(process.cwd(), 'public/photos', folderPath);

// Check if folder exists
if (!fs.existsSync(photosDir)) {
  return Astro.redirect('/404');
}

// Get image files
const imageFiles = fs.readdirSync(photosDir).filter(f => 
  /\.(jpg|jpeg|png|webp|gif)$/i.test(f)
);

// Load tags.json if it exists
const tagsPath = path.join(photosDir, 'tags.json');
const tagsOverride = fs.existsSync(tagsPath) ? 
  JSON.parse(fs.readFileSync(tagsPath, 'utf8')) : {};

// Process each image
const images = imageFiles.map(file => {
  const filename = path.parse(file).name;
  
  // Parse filename for caption: subject_event_year.jpg
  const parts = filename.split('_');
  let subject = '';
  let event = '';
  let year = '';
  
  if (parts.length > 0) {
    subject = parts[0].split('-').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  }
  
  if (parts.length > 1) {
    const lastPart = parts[parts.length - 1];
    if (/^\d{4}$/.test(lastPart)) {
      year = lastPart;
      if (parts.length > 2) {
        event = parts.slice(1, -1).join(' ').split('-').map(word => 
          word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
      }
    } else {
      event = parts.slice(1).join(' ').split('-').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ');
    }
  }
  
  // Build caption
  let caption = subject;
  if (event) caption += ` at ${event}`;
  if (year) caption += ` in ${year}`;
  
  // Get tags from tags.json or parse from filename
  let tags = tagsOverride[file] || [];
  if (tags.length === 0) {
    // Extract tags from filename patterns like _tag1-tag2
    const tagMatch = filename.match(/_([^_]+)$/);
    if (tagMatch) {
      tags = tagMatch[1].split('-');
    }
    // Add folder name(s) as tags
    tags.push(...folderPath.split('/'));
  }
  
  return {
    src: `/photos/${folderPath}/${file}`,
    filename: file,
    caption,
    tags: [...new Set(tags)] // Remove duplicates
  };
});

// Get all unique tags for filtering
const allTags = [...new Set(images.flatMap(img => img.tags))];

// Display name for the gallery
const displayName = folderPath.split('/').map(part => 
  part.split('-').map(word => 
    word.charAt(0).toUpperCase() + word.slice(1)
  ).join(' ')
).join(' â†’ ');

export const getStaticPaths = async () => {
  const photosDir = path.join(process.cwd(), 'public/photos');
  if (!fs.existsSync(photosDir)) return [];
  
  const paths = [];
  
  function getAllFolders(dir, basePath = '') {
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const itemPath = path.join(dir, item);
      const relativePath = basePath ? `${basePath}/${item}` : item;
      
      if (fs.statSync(itemPath).isDirectory()) {
        // Check if this folder has images
        const hasImages = fs.readdirSync(itemPath).some(f => 
          /\.(jpg|jpeg|png|webp|gif)$/i.test(f)
        );
        
        if (hasImages) {
          paths.push({
            params: { folder: relativePath }
          });
        }
        
        // Recursively check subfolders
        getAllFolders(itemPath, relativePath);
      }
    }
  }
  
  getAllFolders(photosDir);
  return paths;
};
---

<MainLayout>
  <section class="py-16 pt-24">
    <div class="container mx-auto px-4 max-w-7xl">
      <!-- Gallery Header -->
      <div class="mb-8 text-center">
        <h1 class="text-3xl md:text-4xl font-bold mb-2">{displayName}</h1>
        <p class="text-gray-600">{images.length} {images.length === 1 ? 'photo' : 'photos'}</p>
      </div>

      <!-- Search and Filter -->
      <div class="mb-8">
        <div class="max-w-md mx-auto mb-6">
          <input 
            type="text" 
            id="search" 
            placeholder="Search photos..."
            class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
        </div>
        
        {allTags.length > 0 && (
          <div class="flex flex-wrap gap-2 justify-center mb-6">
            <button 
              class="tag-filter-all px-3 py-1 text-sm bg-gray-200 hover:bg-gray-300 rounded-full transition-colors"
            >
              All
            </button>
            {allTags.map(tag => (
              <button 
                class="tag-filter px-3 py-1 text-sm border border-gray-300 rounded-full hover:bg-gray-100 transition-colors"
                data-tag={tag}
              >
                {tag}
              </button>
            ))}
          </div>
        )}
      </div>

      <!-- Masonry Gallery -->
      <div id="masonry" class="masonry-items" data-gutter="8px">
        <div class="grid-sizer"></div>
        {images.map((image, index) => {
          const heuristic = index % 7 === 0 ? 'wide-tall'
            : index % 5 === 0 ? 'wide-short'
            : index % 4 === 1 ? 'tall'
            : index % 6 === 2 ? 'wide'
            : index % 8 === 3 ? 'medium'
            : 'regular';

          let variant = 'regular';
          let dataSize = 'portrait';
          if (heuristic === 'wide' || heuristic === 'wide-short') {
            variant = 'wide';
            dataSize = 'landscape';
          } else if (heuristic === 'wide-tall' || heuristic === 'tall') {
            variant = 'wide_tall';
            dataSize = 'xlportrait';
          }

          // Calculate dimensions based on size
          const dimensions = {
            portrait: { w: 320, h: 480 },
            landscape: { w: 648, h: 480 },
            xlportrait: { w: 648, h: 968 }
          };
          const { w, h } = dimensions[dataSize];

          return (
            <article
              class={`masonry-item ${variant}`}
              data-idx={index}
              data-filename={image.filename}
              data-size={dataSize}
              data-caption={image.caption}
              data-tags={JSON.stringify(image.tags)}
            >
              <a class="masonry-link portfolio-lightbox" href={image.src}>
                <Image
                  src={image.src}
                  alt={image.caption}
                  width={w}
                  height={h}
                  layout="responsive"
                  fit="cover"
                  position="attention"
                  loading="lazy"
                  data-caption={image.caption}
                />
                <div class="caption-overlay">
                  <h3>{image.caption}</h3>
                </div>
              </a>
            </article>
          );
        })}
      </div>

      <!-- Comments Section -->
      <PhotoComments galleryName={folderPath} />
    </div>
  </section>
<style>
.masonry-items {
  position: relative;
  width: 100%;
  margin: 0 auto;
  padding: 0;
  min-height: 400px;
}

.masonry-item {
  box-sizing: border-box;
  padding: 0;
  opacity: 0;
  transform: translateY(12px);
  position: absolute;
  overflow: hidden;
}

.masonry-item.animated-in {
  opacity: 1;
  transform: translateY(0);
  transition: opacity .35s ease, transform .35s ease;
}

.grid-sizer {
  width: 320px;
}

.masonry-item.regular {
  width: 320px;
}

.masonry-item.wide,
.masonry-item.wide_tall {
  width: 648px;
}

@media only screen and (max-width: 1300px) {
  .grid-sizer,
  .masonry-item.regular {
    width: 25%;
  }
  .masonry-item.wide,
  .masonry-item.wide_tall {
    width: 50%;
  }
}

@media only screen and (max-width: 768px) {
  .grid-sizer,
  .masonry-item.regular {
    width: 50%;
  }
  .masonry-item.wide,
  .masonry-item.wide_tall {
    width: 100%;
  }
}

@media only screen and (max-width: 480px) {
  .masonry-items {
    display: flex !important;
    flex-direction: column !important;
    gap: 8px !important;
    position: relative !important;
  }

  .grid-sizer {
    display: none !important;
  }

  .masonry-item {
    position: relative !important;
    width: 100% !important;
    height: auto !important;
    transform: none !important;
    left: auto !important;
    top: auto !important;
  }

  .masonry-item img {
    object-fit: contain !important;
    width: 100% !important;
    height: auto !important;
  }
}

.masonry-item img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform 0.45s cubic-bezier(0.3, 0.1, 0.3, 1);
}

.masonry-item a {
  display: block;
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
}

.masonry-item a::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  opacity: 0;
  transition: opacity 0.3s ease;
  z-index: 1;
  pointer-events: none;
}

.masonry-item:hover img {
  transform: scale(1.07);
}

.masonry-item:hover a::before {
  opacity: 1;
}

.caption-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  text-align: center;
  width: 85%;
  max-width: 500px;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  z-index: 2;
  padding: 0 10px;
}

.caption-overlay h3 {
  margin: 0;
  font-size: 24px;
  font-weight: 600;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  letter-spacing: 0.5px;
  line-height: 1.3;
}

.masonry-item:hover .caption-overlay {
  opacity: 1;
}

.tag-filter.active,
.tag-filter.is-active {
  background: #3b82f6;
  color: #fff;
  border-color: transparent;
}

.tag-filter-all.is-active {
  background: #1f2937;
  color: #fff;
}
</style>

<script hoist>
  import initPackeryGallery from '../../scripts/packeryGallery.ts';
  initPackeryGallery({
    container: '#masonry',
    adminMode: false,
    enableToolbar: false,
  });

  const activeTags = new Set();

  document.addEventListener('DOMContentLoaded', () => {
    const searchInput = document.getElementById('search');
    const tagButtons = Array.from(document.querySelectorAll('.tag-filter'));
    const allButton = document.querySelector('.tag-filter-all');
    const items = Array.from(document.querySelectorAll('.masonry-item'));

    const applyFilters = () => {
      const searchTerm = searchInput && 'value' in searchInput ? searchInput.value.toLowerCase() : '';

      items.forEach((item) => {
        const caption = item.getAttribute('data-caption')?.toLowerCase() || '';
        const tags = JSON.parse(item.getAttribute('data-tags') || '[]');

        const matchesSearch = !searchTerm || caption.includes(searchTerm);
        const matchesTags = activeTags.size === 0 || Array.from(activeTags).every((tag) => tags.includes(tag));

        item.style.display = matchesSearch && matchesTags ? '' : 'none';
      });

      const packery = window.pckry;
      if (packery) {
        try {
          packery.layout();
          if (typeof (packery as any).shiftLayout === 'function') {
            (packery as any).shiftLayout();
          }
        } catch (error) {
          console.warn('Packery relayout after filter failed', error);
        }
      }
    };

    searchInput?.addEventListener('input', applyFilters);

    tagButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const tag = button.dataset.tag;
        if (!tag) return;

        if (activeTags.has(tag)) {
          activeTags.delete(tag);
          button.classList.remove('is-active');
        } else {
          activeTags.add(tag);
          button.classList.add('is-active');
        }

        if (allButton) allButton.classList.remove('is-active');
        applyFilters();
      });
    });

    allButton?.addEventListener('click', () => {
      activeTags.clear();
      tagButtons.forEach((btn) => btn.classList.remove('is-active'));
      allButton.classList.add('is-active');
      applyFilters();
    });

    allButton?.classList.add('is-active');
    applyFilters();
  });
</script>
</MainLayout>
