---
import MainLayout from '../layouts/MainLayout.astro';
// Import image configuration
import { images } from '../data/homepage-images.js';

// Set this to false to use your manual image order from homepage-images.js
// Set to true to automatically optimize order to minimize gaps
const AUTO_OPTIMIZE_ORDER = true;

// Algorithm to optimize image order for minimal gaps
function optimizeImageOrder(images) {
  // In AUTO_OPTIMIZE_ORDER, ignore manual order and treat all as unordered
  const orderedImages = [];
  const unorderedImages = images.slice();
  
  // Sort ordered images by their order value
  orderedImages.sort((a, b) => a.order - b.order);
  
  // If no unordered images, just return the ordered ones
  if (unorderedImages.length === 0) {
    return orderedImages;
  }
  
  // Optimize the unordered images
  const sizeGroups = {
    xlportrait: [], // 2x2 - largest, place first for anchor points
    landscape: [],  // 2x1 - horizontal images
    portrait: []    // 1x1 - standard portrait, use to fill gaps
  };
  
  unorderedImages.forEach(img => {
    sizeGroups[img.size].push(img);
  });
  
  const optimizedUnordered = [];
  
  // Strategy: Follow specific pattern for top of page, then distribute remaining items
  
  // Pattern for top section:
  // Row 1: 2 portraits (stacked), xlportrait, 2 portraits (stacked), xlportrait
  // Row 2: xlportrait, landscape (above another xlportrait), landscape
  
  // Row 1 implementation
  // First column: 2 portraits stacked (composite item)
  if (sizeGroups.portrait.length >= 2) {
    const p1 = sizeGroups.portrait.shift();
    const p2 = sizeGroups.portrait.shift();
    optimizedUnordered.push({ type: 'stacked', items: [p1, p2] });
  } else if (sizeGroups.portrait.length === 1) {
    optimizedUnordered.push(sizeGroups.portrait.shift());
  }
  
  // Second column: xlportrait
  if (sizeGroups.xlportrait.length > 0) {
    optimizedUnordered.push(sizeGroups.xlportrait.shift());
  }
  
  // Third column: 2 portraits stacked (composite item)
  if (sizeGroups.portrait.length >= 2) {
    const p3 = sizeGroups.portrait.shift();
    const p4 = sizeGroups.portrait.shift();
    optimizedUnordered.push({ type: 'stacked', items: [p3, p4] });
  } else {
    while (sizeGroups.portrait.length > 0) {
      optimizedUnordered.push(sizeGroups.portrait.shift());
    }
  }
  
  // Fourth column: xlportrait
  if (sizeGroups.xlportrait.length > 0) {
    optimizedUnordered.push(sizeGroups.xlportrait.shift());
  }
  
  // Row 2 implementation
  // First: xlportrait
  if (sizeGroups.xlportrait.length > 0) {
    optimizedUnordered.push(sizeGroups.xlportrait.shift());
  }
  
  // Second: landscape
  if (sizeGroups.landscape.length > 0) {
    optimizedUnordered.push(sizeGroups.landscape.shift());
  }
  
  // Third: another landscape
  if (sizeGroups.landscape.length > 0) {
    optimizedUnordered.push(sizeGroups.landscape.shift());
  }
  
  // Now continue with remaining items, distributing xlportraits with spacing
  const totalXl = sizeGroups.xlportrait.length;
  const totalOtherItems = sizeGroups.portrait.length + sizeGroups.landscape.length;
  const minSpacing = totalXl > 0 ? Math.max(4, Math.floor(totalOtherItems / (totalXl + 1))) : 0;
  
  let itemsSinceLastXl = 0;
  
  // Place remaining items with xlportraits distributed
  while (sizeGroups.portrait.length > 0 || sizeGroups.landscape.length > 0 || sizeGroups.xlportrait.length > 0) {
    
    // Check if we should place an xlportrait (with proper spacing)
    if (sizeGroups.xlportrait.length > 0 && itemsSinceLastXl >= minSpacing) {
      // Place some portraits before xlportrait
      for (let i = 0; i < 2 && sizeGroups.portrait.length > 0; i++) {
        optimizedUnordered.push(sizeGroups.portrait.shift());
      }
      
      // Place the xlportrait
      optimizedUnordered.push(sizeGroups.xlportrait.shift());
      itemsSinceLastXl = 0;
      
      // Place some portraits after xlportrait
      for (let i = 0; i < 2 && sizeGroups.portrait.length > 0; i++) {
        optimizedUnordered.push(sizeGroups.portrait.shift());
      }
      
      // Add a landscape if available
      if (sizeGroups.landscape.length > 0) {
        optimizedUnordered.push(sizeGroups.landscape.shift());
        itemsSinceLastXl++;
      }
    } else {
      // Add regular items between xlportraits
      
      // Add portraits in small batches
      const portraitBatch = Math.min(2, sizeGroups.portrait.length);
      for (let i = 0; i < portraitBatch; i++) {
        if (sizeGroups.portrait.length > 0) {
          optimizedUnordered.push(sizeGroups.portrait.shift());
          itemsSinceLastXl++;
        }
      }
      
      // Add landscape
      if (sizeGroups.landscape.length > 0) {
        optimizedUnordered.push(sizeGroups.landscape.shift());
        itemsSinceLastXl++;
      }
    }
    
    // Safety: place remaining xlportraits if we're running low on other items
    if (sizeGroups.xlportrait.length > 0 && 
        sizeGroups.portrait.length + sizeGroups.landscape.length < 2) {
      while (sizeGroups.xlportrait.length > 0) {
        optimizedUnordered.push(sizeGroups.xlportrait.shift());
      }
    }
  }
  
  // Merge ordered and optimized unordered images
  const result = [];
  let orderedIndex = 0;
  let unorderedIndex = 0;
  
  // Place images according to order values, filling gaps with optimized unordered
  for (let position = 1; orderedIndex < orderedImages.length || unorderedIndex < optimizedUnordered.length; position++) {
    // Check if there's an ordered image for this position
    if (orderedIndex < orderedImages.length && orderedImages[orderedIndex].order === position) {
      result.push(orderedImages[orderedIndex]);
      orderedIndex++;
    } else if (unorderedIndex < optimizedUnordered.length) {
      // Fill with optimized unordered image
      result.push(optimizedUnordered[unorderedIndex]);
      unorderedIndex++;
    }
  }
  
  // Post-pass: break up long runs of portrait-width columns
  // Treat both single portraits and stacked pairs as portrait-width columns
  function isPortraitColumn(item) {
    if (!item) return false;
    if (item.type === 'stacked') return true;
    return !item.type && item.size === 'portrait';
  }
  function isXlPortrait(item) {
    return item && !item.type && item.size === 'xlportrait';
  }
  function isLandscape(item) {
    return item && !item.type && item.size === 'landscape';
  }
  
  let i = 0;
  while (i < result.length) {
    // Find a run of consecutive portrait-width columns
    if (!isPortraitColumn(result[i])) { i++; continue; }
    const start = i;
    let end = i;
    while (end < result.length && isPortraitColumn(result[end])) end++;
    const runLen = end - start;
    
    // If there are too many portrait-width columns in a row, insert a wide item in the middle
    if (runLen >= 6) {
      // Prefer an xlportrait; fallback to a landscape
      let xlIndex = -1;
      for (let k = end; k < result.length; k++) {
        if (isXlPortrait(result[k])) { xlIndex = k; break; }
      }
      // If none after, try before the run
      if (xlIndex === -1) {
        for (let k = start - 1; k >= 0; k--) {
          if (isXlPortrait(result[k])) { xlIndex = k; break; }
        }
      }
      // If still none, try landscape
      let wideWasLandscape = false;
      if (xlIndex === -1) {
        for (let k = end; k < result.length; k++) {
          if (isLandscape(result[k])) { xlIndex = k; wideWasLandscape = true; break; }
        }
        if (xlIndex === -1) {
          for (let k = start - 1; k >= 0; k--) {
            if (isLandscape(result[k])) { xlIndex = k; wideWasLandscape = true; break; }
          }
        }
      }

      if (xlIndex !== -1) {
        const [wide] = result.splice(xlIndex, 1);
        // Build portrait-width columns for this run by pairing single portraits into stacked columns
        const segment = result.slice(start, end);
        const columns = [];
        let carry = null;
        for (const it of segment) {
          if (it && it.type === 'stacked') {
            // flush carry as single column before pushing stacked column
            if (carry) { columns.push(carry); carry = null; }
            columns.push(it);
          } else if (it && !it.type && it.size === 'portrait') {
            if (!carry) {
              carry = it; // hold until we have a pair
            } else {
              columns.push({ type: 'stacked', items: [carry, it] });
              carry = null;
            }
          } else {
            // Non-portrait shouldn't be in this run, but guard anyway
            if (carry) { columns.push(carry); carry = null; }
            columns.push(it);
          }
        }
        if (carry) { columns.push(carry); carry = null; }

        // Decide insertion point at column level
        const splitCols = columns.length >= 8 ? 4 : Math.floor(columns.length / 2);
        const leftCols = columns.slice(0, splitCols);
        const rightCols = columns.slice(splitCols);
        const rebuilt = [...leftCols, wide, ...rightCols];

        // Replace the original segment with rebuilt columns back into flat items
        const flat = [];
        for (const col of rebuilt) {
          if (col && col.type === 'stacked') {
            flat.push(col); // render as a single item (we have renderer for stacked)
          } else {
            flat.push(col);
          }
        }

        // Splice back into result
        result.splice(start, end - start, ...flat);
        // Move i past the rebuilt block
        i = start + flat.length;
        continue;
      }
    }
    
    i = end; // skip past this run
  }
  
  return result;
}

// Decide whether to optimize or use manual order
const processedImages = AUTO_OPTIMIZE_ORDER ? optimizeImageOrder(images) : images;

// Helper to map a single image to render data
function mapSingle(img) {
  return {
    src: `/highlights/${img.filename}`,
    filename: img.filename,
    caption: img.caption || img.filename.replace(/[-_]/g, ' ').replace(/\.\w+$/, ''),
    size: img.size
  };
}
---

<MainLayout>
  <div class="portfolio-wrap">
    <div class="portfolio-items masonry-items" data-masonry-type="photography">
      {processedImages.map((item, index) => {
        if (item && item.type === 'stacked' && Array.isArray(item.items)) {
          const a = mapSingle(item.items[0]);
          const b = mapSingle(item.items[1] || item.items[0]);
          return (
            <div class={`col elastic-portfolio-item stacked`} data-delay-amount={index}>
              <div class="inner-wrap">
                <div class="work-item">
                  <div class="stacked-pair">
                    <a href={a.src} class="portfolio-lightbox">
                      <img src={a.src} alt={a.caption} loading="lazy" data-caption={a.caption} />
                    </a>
                    <a href={b.src} class="portfolio-lightbox">
                      <img src={b.src} alt={b.caption} loading="lazy" data-caption={b.caption} />
                    </a>
                  </div>
                </div>
              </div>
            </div>
          );
        }
        const photo = mapSingle(item);
        return (
          <div class={`col elastic-portfolio-item ${photo.size}`} data-delay-amount={index}>
            <div class="inner-wrap">
              <div class="work-item">
                <a href={photo.src} class="portfolio-lightbox">
                  <img 
                    src={photo.src} 
                    alt={photo.caption}
                    loading="lazy"
                    data-caption={photo.caption}
                  />
                </a>
                <div class="work-info-bg"></div>
                <div class="work-info">
                  <h3>{photo.caption}</h3>
                </div>
              </div>
            </div>
          </div>
        );
      })}
    </div>
  </div>
</MainLayout>

<style>
/* Portfolio container - full width with top spacing for navbar */
.portfolio-wrap {
  position: relative;
  margin: 0;
  padding: 120px 0 0 0; /* Top padding to account for fixed navbar with extra padding */
  width: 100%;
}

/* Masonry Container */
.portfolio-items {
  position: relative;
  width: 100%;
  margin: 0 auto;
  padding: 0;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.portfolio-items.isotope-initialized {
  opacity: 1;
}

/* Base column width - Fixed pixel based */
.portfolio-items .col {
  width: 320px; /* Fixed base width */
  padding: 0;
  margin: 0 0 10px 0; /* Bottom margin for vertical spacing */
  box-sizing: border-box;
  float: left;
}

/* Size variations - User-friendly names */
.portfolio-items .col.portrait {
  width: 320px; /* 1 column width */
}

.portfolio-items .col.stacked {
  width: 320px; /* 1 column width (two portraits stacked) */
}

.portfolio-items .col.landscape {
  width: 650px; /* 2 columns + gap (320*2 + 10) */
}

.portfolio-items .col.xlportrait {
  width: 650px; /* 2 columns + gap */
}

/* Responsive breakpoints */
@media only screen and (max-width: 1600px) {
  .portfolio-items .col.portrait {
    width: 25%; /* 4 columns */
  }
  .portfolio-items .col.stacked {
    width: 25%;
  }
  .portfolio-items .col.landscape,
  .portfolio-items .col.xlportrait {
    width: 50%; /* 2x width */
  }
}

@media only screen and (max-width: 1200px) {
  .portfolio-items .col.portrait {
    width: 33.333%; /* 3 columns */
  }
  .portfolio-items .col.stacked {
    width: 33.333%;
  }
  .portfolio-items .col.landscape,
  .portfolio-items .col.xlportrait {
    width: 66.666%; /* 2x width */
  }
}

@media only screen and (max-width: 768px) {
  .portfolio-items .col.portrait {
    width: 50%; /* 2 columns */
  }
  .portfolio-items .col.stacked {
    width: 50%;
  }
  .portfolio-items .col.landscape,
  .portfolio-items .col.xlportrait {
    width: 100%; /* Full width */
  }
}

@media only screen and (max-width: 480px) {
  .portfolio-items .col,
  .portfolio-items .col.portrait,
  .portfolio-items .col.stacked,
  .portfolio-items .col.landscape,
  .portfolio-items .col.xlportrait {
    width: 100%; /* 1 column on mobile */
  }
}

/* Inner wrapper */
.portfolio-items .col .inner-wrap {
  position: relative;
  overflow: hidden;
  background: #f5f5f5;
}

/* Work item container */
.portfolio-items .col .work-item {
  position: relative;
  overflow: hidden;
  cursor: pointer;
}

/* Images - fixed aspect ratio with cropping */
.portfolio-items .col img {
  width: 100%;
  height: 100%;
  display: block;
  object-fit: cover;
  transition: transform 0.45s cubic-bezier(0.3, 0.1, 0.3, 1);
}

/* Set fixed aspect ratios for each size */
.portfolio-items .col.portrait .work-item {
  aspect-ratio: 2 / 3; /* Vertical orientation */
}

.portfolio-items .col.stacked .work-item {
  height: 970px; /* two portraits + 10px gap */
}

.portfolio-items .col.stacked .stacked-pair {
  display: flex;
  flex-direction: column;
  gap: 10px; /* must match masonry gutter */
  height: 970px;
}

.portfolio-items .col.stacked .stacked-pair a {
  display: block;
  width: 100%;
  height: 480px; /* each portrait height */
  overflow: hidden;
}

.portfolio-items .col.stacked .stacked-pair img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

.portfolio-items .col.landscape .work-item {
  aspect-ratio: 650 / 480; /* Exact ratio for same height as portrait (650px wide, 480px tall) */
}

.portfolio-items .col.xlportrait .work-item {
  /* Height = (2 portraits + gap between)
     For 320px width at 2:3 ratio = 480px per portrait
     480px + 480px + 10px gap = 970px height */
  height: 970px; /* Exactly 2 portrait heights + gap */
  width: 100%;
}

/* Hover effects */
.portfolio-items .col:hover img {
  transform: scale(1.07);
}

/* Work info overlay */
.portfolio-items .work-info-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0);
  transition: background 0.45s ease;
  pointer-events: none;
}

.portfolio-items .col:hover .work-info-bg {
  background: rgba(0, 0, 0, 0.4);
}

.portfolio-items .work-info {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 20px;
  color: #fff;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.portfolio-items .col:hover .work-info {
  opacity: 1;
}

.portfolio-items .work-info h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 400;
}

/* Animation */
@keyframes portfolioFadeIn {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.portfolio-items .col .inner-wrap {
  animation: portfolioFadeIn 0.6s ease forwards;
  opacity: 0;
}

.portfolio-items.animated-in .col .inner-wrap {
  opacity: 1;
}

/* Staggered animation */
.portfolio-items .col:nth-child(1) .inner-wrap { animation-delay: 0ms; }
.portfolio-items .col:nth-child(2) .inner-wrap { animation-delay: 85ms; }
.portfolio-items .col:nth-child(3) .inner-wrap { animation-delay: 170ms; }
.portfolio-items .col:nth-child(4) .inner-wrap { animation-delay: 255ms; }
.portfolio-items .col:nth-child(5) .inner-wrap { animation-delay: 340ms; }
.portfolio-items .col:nth-child(6) .inner-wrap { animation-delay: 425ms; }
.portfolio-items .col:nth-child(7) .inner-wrap { animation-delay: 510ms; }
.portfolio-items .col:nth-child(8) .inner-wrap { animation-delay: 595ms; }
</style>

<!-- Load Isotope and required libraries -->
<script src="https://unpkg.com/imagesloaded@5/imagesloaded.pkgd.min.js"></script>
<script src="https://unpkg.com/isotope-layout@3/dist/isotope.pkgd.min.js"></script>

<script>
  import PhotoSwipeLightbox from 'photoswipe/lightbox';
  import 'photoswipe/style.css';
  
  document.addEventListener('DOMContentLoaded', function() {
    const container = document.querySelector('.portfolio-items');
    
    // Initialize PhotoSwipe Lightbox
    const lightbox = new PhotoSwipeLightbox({
      gallery: '.portfolio-items',
      children: '.portfolio-lightbox',
      pswpModule: () => import('photoswipe'),
      padding: { top: 20, bottom: 20, left: 20, right: 20 },
      wheelToZoom: true,
      imageClickAction: 'close',
      tapAction: 'toggle-controls',
      doubleTapAction: 'zoom',
      preloaderDelay: 0
    });
    
    // Dynamically set image dimensions
    lightbox.addFilter('itemData', (itemData, index) => {
      const linkEl = itemData.element;
      const imgEl = linkEl.querySelector('img');
      
      if (imgEl) {
        // Use natural dimensions or fallback
        itemData.w = imgEl.naturalWidth || 1600;
        itemData.h = imgEl.naturalHeight || 1200;
        itemData.alt = imgEl.alt;
        itemData.title = imgEl.dataset.caption || imgEl.alt;
      }
      
      return itemData;
    });
    
    lightbox.init();
    
    // Wait for images to load, then initialize Isotope
    imagesLoaded(container, function() {
      // Initialize Isotope with optimized masonry layout
      const iso = new Isotope(container, {
        itemSelector: '.col',
        layoutMode: 'masonry',
        masonry: {
          columnWidth: 320, // Fixed column width
          gutter: 10, // 10px gap between columns
          fitWidth: true, // Center the grid
          horizontalOrder: false // Allow vertical optimization for better gap filling
        },
        percentPosition: false,
        transitionDuration: '0.3s',
        isOriginLeft: true,
        sortBy: 'original-order',
        hiddenStyle: {
          opacity: 0,
          transform: 'translateY(30px)'
        },
        visibleStyle: {
          opacity: 1,
          transform: 'translateY(0)'
        }
      });
      
      // Optional: Force relayout after a delay to ensure proper positioning
      setTimeout(() => {
        iso.layout();
      }, 100);
      
      // Add initialized class
      container.classList.add('isotope-initialized');
      
      // Trigger animation
      setTimeout(() => {
        container.classList.add('animated-in');
      }, 100);
      
      // Handle window resize
      let resizeTimer;
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function() {
          iso.layout();
        }, 250);
      });
    });
  });
</script>
