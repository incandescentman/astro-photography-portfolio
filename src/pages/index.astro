---
// Mark this page as prerendered (static)
export const prerender = true;

import MainLayout from '../layouts/MainLayout.astro';
// Import image configuration
import { images } from '../data/homepage-images.js';
import fs from 'fs';
import path from 'path';

// Load saved order from JSON file if it exists
function loadSavedOrder() {
  try {
    const orderPath = path.join(process.cwd(), 'src/data/saved-order.json');
    if (fs.existsSync(orderPath)) {
      const savedOrder = JSON.parse(fs.readFileSync(orderPath, 'utf-8'));
      return savedOrder;
    }
  } catch (e) {
    console.error('Failed to load saved order:', e);
  }
  return null;
}

// Apply saved order to images array
function applySavedOrder(images) {
  const savedOrder = loadSavedOrder();
  if (!savedOrder || !Array.isArray(savedOrder)) {
    return images;
  }
  
  // Create a map of filename to image data
  const imageMap = new Map();
  images.forEach(img => {
    imageMap.set(img.filename, img);
  });
  
  // Build new array in saved order
  const orderedImages = [];
  savedOrder.forEach(item => {
    const filename = typeof item === 'string' ? item : item.filename;
    const imageData = imageMap.get(filename);
    if (imageData) {
      orderedImages.push(imageData);
      imageMap.delete(filename); // Remove from map so we don't duplicate
    }
  });
  
  // Add any remaining images not in saved order
  imageMap.forEach(img => {
    orderedImages.push(img);
  });
  
  return orderedImages;
}

// Set this to false to use your manual image order from homepage-images.js
// Set to true to automatically optimize order to minimize gaps
const AUTO_OPTIMIZE_ORDER = false;

// Algorithm to optimize image order for minimal gaps
function optimizeImageOrder(images) {
  // In AUTO_OPTIMIZE_ORDER, ignore manual order and treat all as unordered
  const orderedImages = [];
  const unorderedImages = images.slice();
  
  // Sort ordered images by their order value
  orderedImages.sort((a, b) => a.order - b.order);
  
  // If no unordered images, just return the ordered ones
  if (unorderedImages.length === 0) {
    return orderedImages;
  }
  
  // Optimize the unordered images
  const sizeGroups = {
    xlportrait: [], // 2x2 - largest, place first for anchor points
    landscape: [],  // 2x1 - horizontal images
    portrait: []    // 1x1 - standard portrait, use to fill gaps
  };
  
  unorderedImages.forEach(img => {
    sizeGroups[img.size].push(img);
  });
  
  const optimizedUnordered = [];
  
  // Strategy: Follow specific pattern for top of page, then distribute remaining items
  
  // Pattern for top section:
  // Row 1: 2 portraits (stacked), xlportrait, 2 portraits (stacked), xlportrait
  // Row 2: xlportrait, landscape (above another xlportrait), landscape
  
  // Row 1 implementation
  // First column: 2 portraits stacked (composite item)
  if (sizeGroups.portrait.length >= 2) {
    const p1 = sizeGroups.portrait.shift();
    const p2 = sizeGroups.portrait.shift();
    optimizedUnordered.push({ type: 'stacked', items: [p1, p2] });
  } else if (sizeGroups.portrait.length === 1) {
    optimizedUnordered.push(sizeGroups.portrait.shift());
  }
  
  // Second column: xlportrait
  if (sizeGroups.xlportrait.length > 0) {
    optimizedUnordered.push(sizeGroups.xlportrait.shift());
  }
  
  // Third column: 2 portraits stacked (composite item)
  if (sizeGroups.portrait.length >= 2) {
    const p3 = sizeGroups.portrait.shift();
    const p4 = sizeGroups.portrait.shift();
    optimizedUnordered.push({ type: 'stacked', items: [p3, p4] });
  } else {
    while (sizeGroups.portrait.length > 0) {
      optimizedUnordered.push(sizeGroups.portrait.shift());
    }
  }
  
  // Fourth column: xlportrait
  if (sizeGroups.xlportrait.length > 0) {
    optimizedUnordered.push(sizeGroups.xlportrait.shift());
  }
  
  // Row 2 implementation
  // First: xlportrait
  if (sizeGroups.xlportrait.length > 0) {
    optimizedUnordered.push(sizeGroups.xlportrait.shift());
  }
  
  // Second: landscape
  if (sizeGroups.landscape.length > 0) {
    optimizedUnordered.push(sizeGroups.landscape.shift());
  }
  
  // Third: another landscape
  if (sizeGroups.landscape.length > 0) {
    optimizedUnordered.push(sizeGroups.landscape.shift());
  }
  
  // Now continue with remaining items, distributing xlportraits with spacing
  const totalXl = sizeGroups.xlportrait.length;
  const totalOtherItems = sizeGroups.portrait.length + sizeGroups.landscape.length;
  const minSpacing = totalXl > 0 ? Math.max(4, Math.floor(totalOtherItems / (totalXl + 1))) : 0;
  
  let itemsSinceLastXl = 0;
  
  // Place remaining items with xlportraits distributed
  while (sizeGroups.portrait.length > 0 || sizeGroups.landscape.length > 0 || sizeGroups.xlportrait.length > 0) {
    
    // Check if we should place an xlportrait (with proper spacing)
    if (sizeGroups.xlportrait.length > 0 && itemsSinceLastXl >= minSpacing) {
      // Place some portraits before xlportrait
      for (let i = 0; i < 2 && sizeGroups.portrait.length > 0; i++) {
        optimizedUnordered.push(sizeGroups.portrait.shift());
      }
      
      // Place the xlportrait
      optimizedUnordered.push(sizeGroups.xlportrait.shift());
      itemsSinceLastXl = 0;
      
      // Place some portraits after xlportrait
      for (let i = 0; i < 2 && sizeGroups.portrait.length > 0; i++) {
        optimizedUnordered.push(sizeGroups.portrait.shift());
      }
      
      // Add a landscape if available
      if (sizeGroups.landscape.length > 0) {
        optimizedUnordered.push(sizeGroups.landscape.shift());
        itemsSinceLastXl++;
      }
    } else {
      // Add regular items between xlportraits
      
      // Add portraits in small batches
      const portraitBatch = Math.min(2, sizeGroups.portrait.length);
      for (let i = 0; i < portraitBatch; i++) {
        if (sizeGroups.portrait.length > 0) {
          optimizedUnordered.push(sizeGroups.portrait.shift());
          itemsSinceLastXl++;
        }
      }
      
      // Add landscape
      if (sizeGroups.landscape.length > 0) {
        optimizedUnordered.push(sizeGroups.landscape.shift());
        itemsSinceLastXl++;
      }
    }
    
    // Safety: place remaining xlportraits if we're running low on other items
    if (sizeGroups.xlportrait.length > 0 && 
        sizeGroups.portrait.length + sizeGroups.landscape.length < 2) {
      while (sizeGroups.xlportrait.length > 0) {
        optimizedUnordered.push(sizeGroups.xlportrait.shift());
      }
    }
  }
  
  // Merge ordered and optimized unordered images
  const result = [];
  let orderedIndex = 0;
  let unorderedIndex = 0;
  
  // Place images according to order values, filling gaps with optimized unordered
  for (let position = 1; orderedIndex < orderedImages.length || unorderedIndex < optimizedUnordered.length; position++) {
    // Check if there's an ordered image for this position
    if (orderedIndex < orderedImages.length && orderedImages[orderedIndex].order === position) {
      result.push(orderedImages[orderedIndex]);
      orderedIndex++;
    } else if (unorderedIndex < optimizedUnordered.length) {
      // Fill with optimized unordered image
      result.push(optimizedUnordered[unorderedIndex]);
      unorderedIndex++;
    }
  }
  
  // Post-pass: break up long runs of portrait-width columns
  // Treat both single portraits and stacked pairs as portrait-width columns
  function isPortraitColumn(item) {
    if (!item) return false;
    if (item.type === 'stacked') return true;
    return !item.type && item.size === 'portrait';
  }
  function isXlPortrait(item) {
    return item && !item.type && item.size === 'xlportrait';
  }
  function isLandscape(item) {
    return item && !item.type && item.size === 'landscape';
  }
  
  let i = 0;
  while (i < result.length) {
    // Find a run of consecutive portrait-width columns
    if (!isPortraitColumn(result[i])) { i++; continue; }
    const start = i;
    let end = i;
    while (end < result.length && isPortraitColumn(result[end])) end++;
    const runLen = end - start;
    
    // If there are too many portrait-width columns in a row, insert a wide item in the middle
    if (runLen >= 6) {
      // Prefer an xlportrait; fallback to a landscape
      let xlIndex = -1;
      for (let k = end; k < result.length; k++) {
        if (isXlPortrait(result[k])) { xlIndex = k; break; }
      }
      // If none after, try before the run
      if (xlIndex === -1) {
        for (let k = start - 1; k >= 0; k--) {
          if (isXlPortrait(result[k])) { xlIndex = k; break; }
        }
      }
      // If still none, try landscape
      let wideWasLandscape = false;
      if (xlIndex === -1) {
        for (let k = end; k < result.length; k++) {
          if (isLandscape(result[k])) { xlIndex = k; wideWasLandscape = true; break; }
        }
        if (xlIndex === -1) {
          for (let k = start - 1; k >= 0; k--) {
            if (isLandscape(result[k])) { xlIndex = k; wideWasLandscape = true; break; }
          }
        }
      }

      if (xlIndex !== -1) {
        const [wide] = result.splice(xlIndex, 1);
        // Build portrait-width columns for this run by pairing single portraits into stacked columns
        const segment = result.slice(start, end);
        const columns = [];
        let carry = null;
        for (const it of segment) {
          if (it && it.type === 'stacked') {
            // flush carry as single column before pushing stacked column
            if (carry) { columns.push(carry); carry = null; }
            columns.push(it);
          } else if (it && !it.type && it.size === 'portrait') {
            if (!carry) {
              carry = it; // hold until we have a pair
            } else {
              columns.push({ type: 'stacked', items: [carry, it] });
              carry = null;
            }
          } else {
            // Non-portrait shouldn't be in this run, but guard anyway
            if (carry) { columns.push(carry); carry = null; }
            columns.push(it);
          }
        }
        if (carry) { columns.push(carry); carry = null; }

        // Decide insertion point at column level
        const splitCols = columns.length >= 8 ? 4 : Math.floor(columns.length / 2);
        const leftCols = columns.slice(0, splitCols);
        const rightCols = columns.slice(splitCols);
        const rebuilt = [...leftCols, wide, ...rightCols];

        // Replace the original segment with rebuilt columns back into flat items
        const flat = [];
        for (const col of rebuilt) {
          if (col && col.type === 'stacked') {
            flat.push(col); // render as a single item (we have renderer for stacked)
          } else {
            flat.push(col);
          }
        }

        // Splice back into result
        result.splice(start, end - start, ...flat);
        // Move i past the rebuilt block
        i = start + flat.length;
        continue;
      }
    }
    
    i = end; // skip past this run
  }
  
  return result;
}

// Decide whether to optimize or use manual order, then apply saved order
const baseImages = AUTO_OPTIMIZE_ORDER ? optimizeImageOrder(images) : images;
const processedImages = applySavedOrder(baseImages);

// Helper to map a single image to render data
function mapSingle(img) {
  return {
    src: `/highlights/${img.filename}`,
    filename: img.filename,
    caption: img.caption || img.filename.replace(/[-_]/g, ' ').replace(/\.\w+$/, ''),
    size: img.size
  };
}
---

<MainLayout>
  <div class="portfolio-wrap">
    <div id="masonry" class="masonry-items elastic" data-col-num="elastic" data-gutter="8px" data-starting-filter="*" data-masonry-type="photography">
      <div class="grid-sizer"></div>
      {processedImages.map((item, index) => {
        if (item && item.type === 'stacked' && Array.isArray(item.items)) {
          const a = mapSingle(item.items[0]);
          const b = mapSingle(item.items[1] || item.items[0]);
          return (
            <article class="masonry-item wide_tall" data-idx={index}>
              <div class="stacked-pair">
                <a class="masonry-link portfolio-lightbox" href={a.src}>
                  <img src={a.src} alt={a.caption} loading="lazy" data-caption={a.caption} />
                  <div class="caption-overlay">
                    <h3>{a.caption}</h3>
                  </div>
                </a>
                <a class="masonry-link portfolio-lightbox" href={b.src}>
                  <img src={b.src} alt={b.caption} loading="lazy" data-caption={b.caption} />
                  <div class="caption-overlay">
                    <h3>{b.caption}</h3>
                  </div>
                </a>
              </div>
            </article>
          );
        }
        const photo = mapSingle(item);
        // Map size to variant names
        let variant = 'regular';
        if (photo.size === 'landscape') variant = 'wide';
        else if (photo.size === 'xlportrait') variant = 'wide_tall';
        else if (photo.size === 'portrait') variant = 'regular';
        
        return (
          <article class={`masonry-item ${variant}`} data-idx={index} data-filename={item.filename} data-size={photo.size}>
            <a class="masonry-link portfolio-lightbox" href={photo.src}>
              <img 
                src={photo.src} 
                alt={photo.caption}
                loading="lazy"
                data-caption={photo.caption}
                data-variant={variant}
              />
              <div class="caption-overlay">
                <h3>{photo.caption}</h3>
              </div>
            </a>
            <!-- Admin controls removed - using double-click instead -->
          </article>
        );
      })}
    </div>
  </div>
</MainLayout>

<style>
/* Portfolio container - full width with top spacing for navbar */
.portfolio-wrap {
  position: relative;
  margin: 0;
  padding: 120px 0 0 0; /* Top padding to account for fixed navbar with extra padding */
  width: 100%;
}

/* Masonry Container */
.masonry-items {
  position: relative;
  width: 100%;
  margin: 0 auto;
  padding: 0;
  min-height: 500px; /* Prevent collapse */
}

/* Base masonry item */
.masonry-item {
  box-sizing: border-box;
  padding: 0;
  opacity: 0;
  transform: translateY(12px);
  position: absolute;
  overflow: hidden;
}

.masonry-item.animated-in {
  opacity: 1;
  transform: translateY(0);
  transition: opacity .35s ease, transform .35s ease;
}

/* Packery requires a sizer for percentPosition math */
.grid-sizer {
  width: 320px;
}

/* Size variants */
.masonry-item.regular {
  width: 320px;
}

.masonry-item.wide {
  width: 648px; /* 2 columns (320*2) + gap (8) */
}

.masonry-item.wide_tall {
  width: 648px; /* 2 columns (320*2) + gap (8) */
}

/* Responsive sizing */
@media only screen and (max-width: 1300px) {
  .grid-sizer,
  .masonry-item.regular {
    width: 25%;
  }
  .masonry-item.wide,
  .masonry-item.wide_tall {
    width: 50%;
  }
  
  /* Scale heights proportionally */
  .masonry-item.regular,
  .masonry-item.wide {
    height: 350px !important;
  }
  .masonry-item.wide_tall {
    height: 708px !important; /* Double height + 8px gap */
  }
}

@media only screen and (max-width: 768px) {
  .grid-sizer,
  .masonry-item.regular {
    width: 50%;
  }
  .masonry-item.wide,
  .masonry-item.wide_tall {
    width: 100%;
  }
  
  /* Further scale heights */
  .masonry-item.regular,
  .masonry-item.wide {
    height: 300px !important;
  }
  .masonry-item.wide_tall {
    height: 608px !important; /* Double height + 8px gap */
  }
}

@media only screen and (max-width: 480px) {
  .grid-sizer,
  .masonry-item.regular,
  .masonry-item.wide,
  .masonry-item.wide_tall {
    width: 100%;
  }
  
  /* Mobile heights */
  .masonry-item.regular,
  .masonry-item.wide {
    height: 400px !important;
  }
  .masonry-item.wide_tall {
    height: 808px !important; /* Double height + 8px gap */
  }
}

/* Images */
.masonry-item img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 0;
  transition: transform 0.45s cubic-bezier(0.3, 0.1, 0.3, 1);
}

/* Set fixed heights for consistent display */
.masonry-item.regular {
  height: 480px !important; /* Standard height */
}

.masonry-item.wide {
  height: 480px !important; /* Same height as regular */
}

.masonry-item.wide_tall {
  height: 968px !important; /* Double height (480*2 + 8px gap) */
}

.masonry-item a {
  display: block;
  width: 100%;
  height: 100%;
}

/* Stacked pair special handling */
.masonry-item .stacked-pair {
  display: flex;
  flex-direction: column;
  gap: 8px;
  height: 100%;
}

.masonry-item .stacked-pair a {
  display: block;
  overflow: hidden;
  flex: 1;
  height: calc(50% - 4px); /* Each image gets half height minus half gap */
}

.masonry-item .stacked-pair img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

/* Caption overlay */
.masonry-item a {
  position: relative;
  overflow: hidden;
}

/* Dark overlay on hover */
.masonry-item a::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  opacity: 0;
  transition: opacity 0.3s ease;
  z-index: 1;
  pointer-events: none;
}

.caption-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  text-align: center;
  width: 85%;
  max-width: 500px;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  z-index: 2;
  padding: 0 10px;
}

.caption-overlay h3 {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  font-size: 28px;
  font-weight: 600;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  letter-spacing: 0.5px;
  line-height: 1.3;
}

/* Hover effects */
.masonry-item:hover img {
  transform: scale(1.07);
}

.masonry-item:hover a::before {
  opacity: 1;
}

.masonry-item:hover .caption-overlay {
  opacity: 1;
}

/* PhotoSwipe caption styling */
.pswp__caption {
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  min-height: 44px;
  padding: 15px 20px;
  background: rgba(0, 0, 0, 0.75);
  color: #fff;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  font-size: 16px;
  text-align: center;
  line-height: 1.4;
  z-index: 10;
}

.pswp--ui-visible .pswp__caption {
  opacity: 1;
}

/* Admin mode styles */
.admin-toolbar {
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  width: 100% !important;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
  color: white !important;
  padding: 12px 20px !important;
  z-index: 99999 !important;
  display: flex !important;
  align-items: center !important;
  gap: 15px !important;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2) !important;
  visibility: visible !important;
  opacity: 1 !important;
}

.admin-badge {
  background: rgba(255,255,255,0.2);
  padding: 6px 12px;
  border-radius: 20px;
  font-weight: 600;
  font-size: 14px;
  margin-right: auto;
}

.admin-btn {
  background: rgba(255,255,255,0.2);
  border: 1px solid rgba(255,255,255,0.3);
  color: white;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.admin-btn:hover {
  background: rgba(255,255,255,0.3);
  transform: translateY(-1px);
}

.admin-btn.success {
  background: #10b981;
  border-color: #10b981;
}

.admin-btn.error {
  background: #ef4444;
  border-color: #ef4444;
}

.admin-btn.warning {
  background: #f59e0b;
  border-color: #f59e0b;
}

/* Admin mode - show drag cursor */
.admin-mode .masonry-item {
  cursor: move;
}

.admin-mode .masonry-item.is-dragging {
  z-index: 100;
  opacity: 0.8;
  transform: scale(1.05);
  transition: none;
}

.admin-mode.is-sorting .masonry-item:not(.is-dragging) {
  opacity: 0.6;
}

/* Visual feedback for draggable items in admin mode */
.admin-mode .masonry-item:hover {
  outline: 2px dashed #667eea;
  outline-offset: 4px;
}

/* Adjust portfolio wrap when admin toolbar is present */
body:has(.admin-toolbar) .portfolio-wrap {
  padding-top: 170px; /* Extra space for admin toolbar */
}

/* Admin mode visual feedback */
.admin-mode .masonry-item {
  position: relative;
}

.admin-mode .masonry-item::before {
  content: "Double-click to edit";
  position: absolute;
  top: 10px;
  left: 10px;
  right: 10px;
  background: rgba(30, 58, 138, 0.9);
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  text-align: center;
  opacity: 0;
  transition: opacity 0.2s ease;
  z-index: 10;
  pointer-events: none;
}

.admin-mode .masonry-item:hover::before {
  opacity: 1;
}

/* Modal for editing */
.edit-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  padding: 24px;
  border-radius: 12px;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  z-index: 100000;
  min-width: 400px;
}

.edit-modal h3 {
  margin: 0 0 16px 0;
  font-size: 20px;
  font-weight: 600;
}

.edit-modal label {
  display: block;
  margin-bottom: 8px;
  font-size: 14px;
  font-weight: 500;
}

.edit-modal .edit-section {
  margin-bottom: 16px;
}

.edit-modal input,
.edit-modal select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  font-size: 14px;
  margin-bottom: 16px;
}

.edit-modal .button-group {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}

.edit-modal button {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.edit-modal .save-btn {
  background: #1e3a8a;
  color: white;
  border: none;
}

.edit-modal .cancel-btn {
  background: #f3f4f6;
  color: #374151;
  border: none;
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 99999;
}
</style>

<script>
  import PhotoSwipeLightbox from 'photoswipe/lightbox';
  import 'photoswipe/style.css';
  import Packery from 'packery';
  import imagesLoaded from 'imagesloaded';
  import Draggabilly from 'draggabilly';
  
  // Check for admin mode (add ?admin=true to URL)
  const urlParams = new URLSearchParams(window.location.search);
  const isAdminMode = urlParams.get('admin') === 'true';
  console.log('Admin mode:', isAdminMode, 'URL params:', window.location.search);
  
  // Create admin toolbar immediately if in admin mode
  if (isAdminMode) {
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Creating admin toolbar on DOMContentLoaded...');
      const toolbar = document.createElement('div');
      toolbar.className = 'admin-toolbar';
      // Apply beautiful Tailwind-inspired inline styles
      toolbar.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        width: 100% !important;
        height: 72px !important;
        background: #1e3a8a !important;
        color: white !important;
        padding: 16px 24px !important;
        z-index: 999999 !important;
        display: flex !important;
        align-items: center !important;
        gap: 16px !important;
        box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04) !important;
        visibility: visible !important;
        opacity: 1 !important;
        box-sizing: border-box !important;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
        backdrop-filter: blur(10px) !important;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
      `;
      toolbar.innerHTML = `
        <div style="display: flex; align-items: center; gap: 12px; margin-right: auto;">
          <div style="
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
          ">✨</div>
          <div>
            <div style="
              font-weight: 700;
              font-size: 16px;
              letter-spacing: -0.025em;
              text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            ">Admin Mode</div>
            <div style="
              font-size: 12px;
              opacity: 0.9;
              margin-top: 2px;
            ">Drag to resequence • Changes auto-save</div>
          </div>
        </div>
        
        <button id="save-order" style="
          background: rgba(255, 255, 255, 0.2);
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.3);
          color: white;
          padding: 10px 20px;
          border-radius: 12px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          transition: all 0.2s ease;
          display: flex;
          align-items: center;
          gap: 8px;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
          letter-spacing: -0.025em;
        " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 10px 15px -3px rgba(0, 0, 0, 0.1)';" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 6px -1px rgba(0, 0, 0, 0.1)';">
          <span>💾</span> Save Sequence
        </button>
        
        <button id="reset-order" style="
          background: rgba(255, 255, 255, 0.1);
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.2);
          color: white;
          padding: 10px 20px;
          border-radius: 12px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          transition: all 0.2s ease;
          display: flex;
          align-items: center;
          gap: 8px;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
          letter-spacing: -0.025em;
        " onmouseover="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 10px 15px -3px rgba(0, 0, 0, 0.1)';" onmouseout="this.style.background='rgba(255, 255, 255, 0.1)'; this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 6px -1px rgba(0, 0, 0, 0.1)';">
          <span>↺</span> Reset
        </button>
        
        <button id="export-order" style="
          background: rgba(255, 255, 255, 0.1);
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.2);
          color: white;
          padding: 10px 20px;
          border-radius: 12px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          transition: all 0.2s ease;
          display: flex;
          align-items: center;
          gap: 8px;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
          letter-spacing: -0.025em;
        " onmouseover="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 10px 15px -3px rgba(0, 0, 0, 0.1)';" onmouseout="this.style.background='rgba(255, 255, 255, 0.1)'; this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 6px -1px rgba(0, 0, 0, 0.1)';">
          <span>📥</span> Export
        </button>
      `;
      document.body.insertBefore(toolbar, document.body.firstChild);
      
      // Also ensure body has padding to show content below toolbar
      document.body.style.paddingTop = '72px';
      
      console.log('Admin toolbar should now be visible');
    });
  }
  
  document.addEventListener('DOMContentLoaded', function() {
    const container = document.querySelector('#masonry');
    if (!container) return;
    
    // Initialize Packery directly (not as Isotope plugin)
    const pckry = new Packery(container, {
      itemSelector: '.masonry-item',
      columnWidth: '.grid-sizer',
      gutter: 8,
      percentPosition: false,
      transitionDuration: '0.35s',
      stagger: 30,
      resize: true,
      initLayout: false, // Don't layout immediately
      horizontal: false, // Vertical layout for better gap filling
      originLeft: true,
      originTop: true
    });
    
    // Restore saved order on load
    const savedOrder = localStorage.getItem('photoOrder');
    if (savedOrder) {
      try {
        const orderArray = JSON.parse(savedOrder);
        const items = Array.from(container.querySelectorAll('.masonry-item'));

        // Build lookup maps using the FIRST <img> in each masonry item
        const filenameMap = new Map(); // filename -> element
        const captionMap = new Map();  // caption  -> element (legacy fallback)
        items.forEach(item => {
          const img = item.querySelector('img');
          if (!img) return;
          const src = img.getAttribute('src') || '';
          const filename = src.split('/').pop() || '';
          const caption = img.getAttribute('alt') || '';
          if (filename) filenameMap.set(filename, item);
          if (caption) captionMap.set(caption, item);
        });

        // Determine if saved order looks like filenames or captions
        const looksLikeFilenames = orderArray.every(v => typeof v === 'string' && /\.[a-zA-Z0-9]+$/.test(v));

        // Reorder DOM based on saved order (prefer filenames, fallback to captions)
        orderArray.forEach(key => {
          const item = (looksLikeFilenames ? filenameMap.get(key) : (filenameMap.get(key) || captionMap.get(key)));
          if (item) container.appendChild(item);
        });

        console.log('Restored saved order');
      } catch (e) {
        console.error('Failed to restore order:', e);
      }
    }
    
    // Set up admin mode features
    if (isAdminMode) {
      // Add admin mode class to container
      container.classList.add('admin-mode');
      
      // Add double-click handler for editing
      let lastClickTime = 0;
      let lastClickedItem = null;
      
      container.addEventListener('click', (e) => {
        const item = e.target.closest('.masonry-item');
        if (!item) return;
        
        // Don't interfere with dragging
        if (item.classList.contains('is-dragging')) return;
        
        const currentTime = Date.now();
        
        // Check for double-click (same item clicked within 500ms)
        if (lastClickedItem === item && currentTime - lastClickTime < 500) {
          e.preventDefault();
          e.stopPropagation();
          
          // Get image metadata
          const img = item.querySelector('img');
          const filename = item.getAttribute('data-filename') || img?.src?.split('/').pop() || '';
          const currentSize = item.getAttribute('data-size') || 'portrait';
          const currentCaption = img?.getAttribute('alt')?.replace('Jay Dixit photo: ', '') || '';
          
          // Create combined edit modal
          const overlay = document.createElement('div');
          overlay.className = 'modal-overlay';
          
          const modal = document.createElement('div');
          modal.className = 'edit-modal';
          modal.innerHTML = `
            <h3>Edit Image</h3>
            <label style="color: #666; font-size: 12px; margin-bottom: 16px; display: block;">File: ${filename}</label>
            
            <div class="edit-section">
              <label>Size:</label>
              <select id="size-select">
                <option value="portrait" ${currentSize === 'portrait' ? 'selected' : ''}>Portrait (1 column)</option>
                <option value="landscape" ${currentSize === 'landscape' ? 'selected' : ''}>Landscape (2 columns × 1 row)</option>
                <option value="xlportrait" ${currentSize === 'xlportrait' ? 'selected' : ''}>XL Portrait (2 columns × 2 rows)</option>
              </select>
            </div>
            
            <div class="edit-section">
              <label>Caption:</label>
              <input type="text" id="caption-input" value="${currentCaption.replace(/"/g, '&quot;')}" />
            </div>
            
            <div class="button-group">
              <button class="cancel-btn">Cancel</button>
              <button class="save-btn">Save Changes</button>
            </div>
          `;
          
          document.body.appendChild(overlay);
          document.body.appendChild(modal);
          
          // Focus caption input
          setTimeout(() => {
            const input = modal.querySelector('#caption-input');
            if (input) {
              input.focus();
              input.select();
            }
          }, 100);
          
          // Handle cancel
          modal.querySelector('.cancel-btn').addEventListener('click', () => {
            overlay.remove();
            modal.remove();
          });
          
          // Handle save
          modal.querySelector('.save-btn').addEventListener('click', async () => {
            const newSize = modal.querySelector('#size-select').value;
            const newCaption = modal.querySelector('#caption-input').value;
            
            // Update the item's size
            item.setAttribute('data-size', newSize);
            item.className = 'masonry-item ' + (newSize === 'landscape' ? 'wide' : newSize === 'xlportrait' ? 'wide_tall' : 'regular');
            
            // Update the caption
            if (img) {
              img.setAttribute('alt', 'Jay Dixit photo: ' + newCaption);
              img.setAttribute('data-caption', newCaption);
            }
            const captionOverlay = item.querySelector('.caption-overlay h3');
            if (captionOverlay) {
              captionOverlay.textContent = newCaption;
            }
            
            // Save to server
            await saveImageMetadata(filename, { size: newSize, caption: newCaption });
            
            // Relayout masonry
            if (window.pckry) {
              window.pckry.layout();
            }
            
            overlay.remove();
            modal.remove();
          });
          
          // Handle ESC key
          const handleEsc = (e) => {
            if (e.key === 'Escape') {
              overlay.remove();
              modal.remove();
              document.removeEventListener('keydown', handleEsc);
            }
          };
          document.addEventListener('keydown', handleEsc);
          
          // Reset for next double-click
          lastClickedItem = null;
          lastClickTime = 0;
        } else {
          // First click - record it
          lastClickedItem = item;
          lastClickTime = currentTime;
        }
      });
      
      // Function to save metadata changes
      async function saveImageMetadata(filename, updates) {
        try {
          // Get current saved order
          const savedOrder = JSON.parse(localStorage.getItem('photoOrder') || '[]');
          
          // Get all current items with their metadata
          const items = Array.from(container.querySelectorAll('.masonry-item'));
          const metadata = items.map(item => {
            const img = item.querySelector('img');
            const itemFilename = item.getAttribute('data-filename');
            const size = item.getAttribute('data-size');
            const caption = img?.getAttribute('alt') || '';
            
            // Apply updates if this is the edited item
            if (itemFilename === filename) {
              return {
                filename: itemFilename,
                caption: updates.caption !== undefined ? updates.caption : caption,
                size: updates.size !== undefined ? updates.size : size
              };
            }
            
            return {
              filename: itemFilename,
              caption: caption,
              size: size
            };
          });
          
          // Save to server
          const response = await fetch('/api/save-order', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(metadata)
          });
          
          if (response.ok) {
            console.log('Metadata saved successfully');
          }
        } catch (error) {
          console.error('Error saving metadata:', error);
        }
      }
      
      // Save order button - saves to both localStorage and server
      document.getElementById('save-order')?.addEventListener('click', async () => {
        const items = pckry.getItemElements();
        const order = items.map(item => {
          const img = item.querySelector('img');
          const src = img?.getAttribute('src') || '';
          const filename = item.getAttribute('data-filename') || src.split('/').pop();
          const size = item.getAttribute('data-size') || 'portrait';
          return {
            filename: filename,
            caption: img?.getAttribute('alt') || '',
            size: size
          };
        });
        
        // Save to localStorage for immediate use (use filenames to avoid caption collisions)
        const orderFilenames = order.map(o => o.filename).filter(Boolean);
        localStorage.setItem('photoOrder', JSON.stringify(orderFilenames));
        
        // Also save to server for permanent storage
        try {
          const response = await fetch('/api/save-order', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            // Send the array directly for maximum compatibility
            body: JSON.stringify(order)
          });
          
          const result = await response.json();
          
          // Show confirmation
          const btn = document.getElementById('save-order');
          if (btn) {
            if (response.ok) {
              btn.textContent = 'Sequence Saved!';
              btn.style.background = '#10b981';
              console.log('Sequence saved to server:', result);
            } else {
              btn.textContent = 'Error Saving';
              btn.style.background = '#ef4444';
              console.error('Failed to save to server:', result);
            }
            setTimeout(() => {
              btn.textContent = 'Save Sequence';
              btn.style.background = '';
            }, 3000);
          }
        } catch (error) {
          console.error('Error saving to server:', error);
          // Still saved to localStorage at least
          const btn = document.getElementById('save-order');
          if (btn) {
            btn.textContent = 'Saved Locally';
            btn.classList.add('warning');
            setTimeout(() => {
              btn.textContent = 'Save Order';
              btn.classList.remove('warning');
            }, 2000);
          }
        }
      });
      
      // Reset order button
      document.getElementById('reset-order')?.addEventListener('click', () => {
        if (confirm('Reset to default order?')) {
          localStorage.removeItem('photoOrder');
          window.location.reload();
        }
      });
      
      // Export order button
      document.getElementById('export-order')?.addEventListener('click', () => {
        const items = pckry.getItemElements();
        const order = items.map(item => {
          const img = item.querySelector('img');
          const src = img?.getAttribute('src') || '';
          const filename = src.split('/').pop();
          return {
            filename: filename,
            caption: img?.getAttribute('alt') || ''
          };
        });
        
        // Create downloadable JSON
        const dataStr = JSON.stringify(order, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportLink = document.createElement('a');
        exportLink.setAttribute('href', dataUri);
        exportLink.setAttribute('download', 'photo-order.json');
        document.body.appendChild(exportLink);
        exportLink.click();
        document.body.removeChild(exportLink);
      });
    }
    
    // Layout after images load
    imagesLoaded(container, function() {
      pckry.layout();
      
      // Packery's shiftLayout method fills gaps better
      pckry.shiftLayout();
      
      // Sort items to fill gaps - move smaller items to fill holes
      const items = pckry.getItemElements();
      
      // Fit each item to fill available gaps
      items.forEach(item => {
        pckry.fit(item);
      });
      
      // Final layout pass
      pckry.layout();
      
      // Make items draggable
      const allItems = container.querySelectorAll('.masonry-item');
      allItems.forEach((item, i) => {
        // Add animation classes
        setTimeout(() => {
          item.classList.add('animated-in');
        }, i * 60);
        
        // Only make draggable in admin mode
        if (isAdminMode) {
          const draggie = new Draggabilly(item, {
            handle: '.masonry-link', // Drag by clicking the image
            containment: container
          });
          
          let isDragging = false;
          
          // Add visual feedback during drag
          draggie.on('dragStart', function(event, pointer) {
            isDragging = true;
            item.classList.add('is-dragging');
            container.classList.add('is-sorting');
            
            // Prevent lightbox from opening when dragging
            const links = item.querySelectorAll('.masonry-link');
            links.forEach(link => {
              link.style.pointerEvents = 'none';
            });
          });
          
          draggie.on('dragEnd', function() {
            // Re-enable links after a short delay to prevent accidental clicks
            setTimeout(() => {
              isDragging = false;
              const links = item.querySelectorAll('.masonry-link');
              links.forEach(link => {
                link.style.pointerEvents = '';
              });
            }, 100);
            
            item.classList.remove('is-dragging');
            container.classList.remove('is-sorting');
          });
          
          // Prevent click events during drag
          item.addEventListener('click', function(e) {
            if (isDragging) {
              e.preventDefault();
              e.stopPropagation();
            }
          }, true);
          
          // Bind Draggabilly events to Packery
          pckry.bindDraggabillyEvents(draggie);
        }
      });
      
      // Auto-save to localStorage only when drag ends (only in admin mode)
      if (isAdminMode) {
        pckry.on('dragItemPositioned', function() {
          // Get current order
          const items = pckry.getItemElements();
          const orderFilenames = items.map(item => {
            const img = item.querySelector('img');
            if (!img) return '';
            const src = img.getAttribute('src') || '';
            return src.split('/').pop() || '';
          }).filter(Boolean);

          // Auto-save to localStorage only (not server)
          localStorage.setItem('photoOrder', JSON.stringify(orderFilenames));
          console.log('Sequence auto-saved locally');
        });
      }
    });
    
    // Also layout as each image loads for progressive rendering
    imagesLoaded(container).on('progress', function() {
      pckry.shiftLayout();
    });
    
    // Relayout on resize
    let resizeTO;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTO);
      resizeTO = setTimeout(() => {
        pckry.layout();
        pckry.shiftLayout();
      }, 100);
    });
    
    // Initialize PhotoSwipe Lightbox
    const lightbox = new PhotoSwipeLightbox({
      gallery: '.masonry-items',
      children: '.portfolio-lightbox',
      pswpModule: () => import('/node_modules/photoswipe/dist/photoswipe.esm.js'),
      padding: { top: 20, bottom: 80, left: 20, right: 20 }, // Extra bottom padding for caption
      wheelToZoom: true,
      imageClickAction: 'close',
      tapAction: 'toggle-controls',
      doubleTapAction: 'zoom',
      preloaderDelay: 0,
      showHideAnimationType: 'fade'
    });
    
    // Prevent lightbox from opening if dragging
    if (isAdminMode) {
      lightbox.on('clickEvent', (e) => {
        const item = e.originalEvent.target.closest('.masonry-item');
        if (item && item.classList.contains('is-dragging')) {
          e.preventDefault();
        }
      });
    }
    
    // Dynamically set image dimensions
    lightbox.addFilter('itemData', (itemData, index) => {
      const linkEl = itemData.element;
      const imgEl = linkEl.querySelector('img');
      
      if (imgEl) {
        // Use natural dimensions or fallback
        itemData.w = imgEl.naturalWidth || 1600;
        itemData.h = imgEl.naturalHeight || 1200;
        itemData.alt = imgEl.alt;
        // Set caption from data-caption attribute
        const caption = imgEl.getAttribute('data-caption') || imgEl.alt || '';
        if (caption) {
          itemData.title = caption;
        }
      }
      
      return itemData;
    });
    
    // Add caption support with simpler approach
    lightbox.on('uiRegister', function() {
      lightbox.pswp.ui.registerElement({
        name: 'custom-caption',
        order: 9,
        isButton: false,
        appendTo: 'root',
        onInit: (el, pswp) => {
          // Create caption element
          el.style.position = 'absolute';
          el.style.left = '0';
          el.style.bottom = '0';
          el.style.width = '100%';
          el.style.maxWidth = '100%';
          el.style.padding = '15px 20px';
          el.style.background = 'rgba(0, 0, 0, 0.75)';
          el.style.color = '#fff';
          el.style.fontSize = '16px';
          el.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif';
          el.style.textAlign = 'center';
          el.style.lineHeight = '1.4';
          el.style.zIndex = '10';
          
          pswp.on('change', () => {
            const currSlideData = pswp.currSlide?.data;
            if (currSlideData?.title) {
              el.innerHTML = currSlideData.title;
              el.style.display = 'block';
            } else {
              el.style.display = 'none';
            }
          });
          
          // Set initial caption
          setTimeout(() => {
            const currSlideData = pswp.currSlide?.data;
            if (currSlideData?.title) {
              el.innerHTML = currSlideData.title;
              el.style.display = 'block';
            }
          }, 0);
        }
      });
    });
    
    lightbox.init();
  });
</script>
