#+TITLE: Jay Dixit Photography Portfolio - Design Architecture
#+AUTHOR: Claude Code Implementation
#+DATE: 2025-08-20

* Overview

This document outlines the complete architecture and implementation of the Jay Dixit Photography Portfolio, a static site generator (SSG)-powered photography portfolio using Astro.

** Goal
Create a professional photography portfolio that showcases Jay Dixit's work through:
- Automatic gallery generation from folder structures
- Beautiful masonry layouts with varied photo sizes
- Search and filtering capabilities
- Interactive features (likes, comments)
- Mobile-responsive design matching the original photos.jaydixit.com

** Purpose
- Provide a low-maintenance, high-impact portfolio solution
- Enable quick photo uploads via simple folder organization
- Maintain professional presentation while being easy to manage
- Support both highlight showcases and organized galleries

* Architecture

** Photos

Here's a battle-tested way to do photo galleries in Astro that scales cleanly, stays fast on Vercel, and doesn't bloat your builds.

*** The architecture (what works best)

- *Store images in object storage + CDN* (not in the repo): Supabase Storage (with its built-in on-the-fly image transformations), Cloudinary, or ImageKit. For you, *Supabase Storage + Transformations* is the smoothest fit. It serves resized/optimized variants via URL params (WebP/AVIF, width, quality), so you don't rebuild the site every time you add photos. ([Supabase][1])
- *Keep only metadata in the repo* (albums, captions, tags) using *Astro Content Collections*. You get types, schema validation, and fast queries. ([Astro Docs][2])
- *Render with a modern lightbox* such as *PhotoSwipe*; it plays nicely with Astro and is simple to wire up. ([launchfa.st][3], [DEV Community][4])
- *Use a masonry-style layout* for visual density. Native CSS Masonry is arriving (and increasingly supported); otherwise use CSS columns or a lightweight JS fallback. ([MDN Web Docs][5], [Chrome for Developers][6], [CSS-Tricks][7])
- *Lean on responsive images & lazy-loading*. In Astro, the built-in image tools are great for local assets; for remote/CDN images, you still get `<img loading="lazy">` + `srcset/sizes` via your provider. (Astro's image guide explains where its optimizer applies.) ([Astro Docs][8])

*** Why not put photos in the repo?

- Thousands of images = huge git history + long builds.
- Astro's optimizer targets *local* images; for remote stores you should offload transforms to a service (Supabase/Cloudinary/etc.). ([Astro Docs][8])

*** Concrete setup (Supabase-first)

1. *Buckets & URLs*

- Create a bucket per collection (e.g., `events/tiFF-2025`, `portraits/...`).
- Serve via the public CDN URL. Supabase adds *image transformations* via URL params like `?width=1600&quality=70&format=webp`. ([Supabase][1])

2. *Albums as content*

- Make a `src/content/albums/` collection with schema: title, date, cover, location, tags, and an array of photo objects `{ src, width, height, alt, exif }`. Content Collections give you typed content and nice DX. ([Astro Docs][2])

3. *Gallery UI*

- Grid layout with CSS Masonry (where available) or `column-count` fallback; lazy-load thumbnails (`~400-600px` wide) with a blurred placeholder (use your provider's tiny width param as LQIP). Add PhotoSwipe for fullscreen zoom, keyboard nav, and swipe. ([MDN Web Docs][5], [CSS-Tricks][7], [launchfa.st][3], [DEV Community][4])

4. *Responsive source sets*

- For each image, render `srcset` at e.g. 480 / 768 / 1024 / 1600 widths; let the browser pick. Supabase transforms handle the sizing & format (WebP/AVIF) at the edge. ([Supabase][1])

5. *Performance & SEO*

- Pagination or infinite scroll on album pages (avoid loading 200 images at once).
- Add structured data (`CollectionPage` with `ImageObject`s) and a sitemap entry for each album.
- Preload the first viewport's worth of thumbnails only.

*** Nice extras

- *EXIF → captions*: read EXIF on upload (or at build via a small script) to auto-fill camera/lens, shutter, location --- great for your red carpet sets.
- *Dominant-color placeholders*: render a tiny 8-16px image or use a dominant color as a background to eliminate CLS.
- *Tag routes*: generate `/albums/tag/portrait/` pages via Content Collections queries. ([Astro Docs][2])
- *Accessibility*: require `alt` text in the collection schema; PhotoSwipe supports captions.

*** If you prefer Cloudinary/ImageKit instead

- Similar flow: store originals, render with transformation URLs (`f_avif,q_auto,w_...`). Both have excellent CDNs, analytics, and cropping/faces. (Uploadcare has a good Astro guide too if you want a hosted uploader.) ([Uploadcare][9])

*** Quick decision tree

- *< 200 photos total, rarely updated?* You can keep images local and use Astro's `<Image />` to pre-optimize at build --- simplest, but avoid growth pains. ([Astro Docs][8])
- *Hundreds/thousands of photos, frequent updates?* Use Supabase/Cloudinary (CDN + on-the-fly transforms), albums as Content Collections, PhotoSwipe lightbox, and a masonry layout. ([Supabase][1], [Astro Docs][2], [launchfa.st][3])

If you want, I can sketch a minimal Astro page (+ Content Collection schema) that wires up: Supabase URLs → responsive `srcset` → CSS masonry → PhotoSwipe.

[1]: https://supabase.com/docs/guides/storage/serving/image-transformations?utm_source=chatgpt.com "Storage Image Transformations | Supabase Docs"
[2]: https://docs.astro.build/en/guides/content-collections/?utm_source=chatgpt.com "Content collections --- Astro Docs"
[3]: https://www.launchfa.st/blog/photoswipe-astro/?utm_source=chatgpt.com "Using PhotoSwipe in Astro to Build an Image Gallery"
[4]: https://dev.to/petrovicz/astro-photoswipe-549a?utm_source=chatgpt.com "Astro + PhotoSwipe"
[5]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_grid_layout/Masonry_layout?utm_source=chatgpt.com "Masonry layout --- MDN --- Mozilla"
[6]: https://developer.chrome.com/blog/masonry-update?utm_source=chatgpt.com "Brick by brick: Help us build CSS Masonry | Blog"
[7]: https://css-tricks.com/css-masonry-css-grid/?utm_source=chatgpt.com "CSS Masonry & CSS Grid"
[8]: https://docs.astro.build/en/guides/images/?utm_source=chatgpt.com "Images --- Astro Docs"
[9]: https://uploadcare.com/blog/how-to-optimize-images-in-astro/?utm_source=chatgpt.com "How to optimize images in Astro: A step-by-step guide"

** Cloudinary
Amazing --- Cloudinary it is. Here's a clean, low-maintenance setup for Astro where everything looks great automatically, without you hand-tuning URLs.

*** What we'll do

- Use a *named transformation* so every image is auto-optimized and smart-cropped the same way.
- Keep *album metadata* in Astro Content Collections.
- Generate *responsive `srcset`* and lazy-load thumbnails.
- Add a *lightbox* (PhotoSwipe) for fullscreen viewing.

*** 1) Cloudinary setup (one-time)

1. Create an account and note your *cloud name*.

2. In the Cloudinary Console → *Settings → Transformations → Add named transformation*.
   Name it `gallery` and include at least:

   * `c_fill` --- fill the target box
   * `g_auto` --- smart "gravity" (auto focal point)
   * `f_auto` --- modern formats (WebP/AVIF) automatically
   * `q_auto` --- automatic quality
   * Optional (nice for uniform grids): `ar_4:3` or `ar_3:2` to enforce aspect ratio; add `b_auto:border` if you want subtle borders.

   Your named transform becomes `t_gallery`.

3. Upload photos (drag/drop in Media Library). Copy each asset's *public ID* (e.g., `events/tiff_2025/IMG_1234`).

This gives you URLs like:

#+end_src 

https://res.cloudinary.com/<cloud>/image/upload/t_gallery,w_1600/events/tiff_2025/IMG_1234.jpg
#+end_src 

You won't tweak these per image --- Astro will generate widths automatically.

*** 2) Astro: Content Collections for albums

`src/content/config.ts`

#+begin_src ts
import { defineCollection, z } from "astro:content";

const albums = defineCollection({
  type: "data",
  schema: z.object({
    title: z.string(),
    date: z.string(),
    coverPublicId: z.string(),
    photos: z.array(z.object({
      publicId: z.string(),
      alt: z.string().min(1).default(""),
      width: z.number().optional(),   // optional if you have native dims
      height: z.number().optional()
    })),
    tags: z.array(z.string()).optional()
  })
});

export const collections = { albums };
#+end_src 

Example album file `src/content/albums/tiff-2025.json`

#+begin_src json
{
  "title": "TIFF 2025 --- Red Carpet",
  "date": "2025-09-12",
  "coverPublicId": "events/tiff_2025/IMG_0001",
  "tags": ["red-carpet", "portrait"],
  "photos": [
    { "publicId": "events/tiff_2025/IMG_0001", "alt": "Maria Ressa at TIFF" },
    { "publicId": "events/tiff_2025/IMG_0002", "alt": "Jude Law greeting fans" }
  ]
}
#+end_src 

*** 3) A tiny Cloudinary URL helper (no SDK needed)

`src/lib/cloudinary.ts`

#+begin_src ts
const CLOUD = import.meta.env.PUBLIC_CLOUDINARY_CLOUD_NAME; // set in .env

// Generate a Cloudinary delivery URL with your named transform and width.
export function cldUrl(publicId: string, width: number) {
  const base = `https://res.cloudinary.com/${CLOUD}/image/upload`;
  return `${base}/t_gallery,w_${width}/${publicId}.jpg`;
}

// Build a srcset string once, reuse everywhere.
export function cldSrcset(publicId: string, widths = [480, 768, 1024, 1600, 2200]) {
  return widths.map(w => `${cldUrl(publicId, w)} ${w}w`).join(", ");
}
#+end_src 

`.env`

#+end_src 

PUBLIC_CLOUDINARY_CLOUD_NAME=your_cloud_name
#+end_src 

*** 4) Gallery component (masonry grid + lazy images)

`src/components/Gallery.astro`

#+begin_src astro
import type { CollectionEntry } from "astro:content";
import { cldUrl, cldSrcset } from "@/lib/cloudinary";

const { album } = Astro.props as { album: CollectionEntry<"albums">["data"] };

// Responsive rules: 3 columns desktop, 2 tablet, 1 mobile
const sizes = "(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw";

<section class="mx-auto max-w-7xl px-4 md:px-6">
  <h1 class="text-2xl md:text-3xl font-semibold mb-4">{album.title}</h1>
  <div class="masonry columns-1 sm:columns-2 lg:columns-3 gap-4 [column-fill:_balance]">
    {album.photos.map((p, i) => {
      const src = cldUrl(p.publicId, 1024);
      const srcset = cldSrcset(p.publicId);
      return (
        <a
          href={cldUrl(p.publicId, 2200)}
          data-pswp-width="2200"
          data-pswp-height="1467"
          class="block mb-4 break-inside-avoid"
        >
          <img
            src={src}
            srcset={srcset}
            sizes={sizes}
            alt={p.alt}
            loading="lazy"
            decoding="async"
            class="w-full h-auto rounded-xl shadow-sm"
            fetchpriority={i === 0 ? "high" : "auto"}
          />
        </a>
      );
    })}
  </div>
</section>

<style>
/* Minimal masonry via CSS columns; images are blocks that avoid breaks */
.masonry img { display: block; }
</style>
#+end_src 

This:

- Uses your `t_gallery` named transform for *smart crop, auto-format, auto-quality*.
- Generates `srcset` breakpoints for responsive loading.
- Lazy-loads everything except the first image.

*** 5) Lightbox (PhotoSwipe) in Astro

Install:

#+begin_src bash
npm i photoswipe
#+end_src 

`src/components/Lightbox.client.ts`

#+begin_src ts
import PhotoSwipeLightbox from "photoswipe/lightbox";
import "photoswipe/style.css";

export default () => {
  const lightbox = new PhotoSwipeLightbox({
    gallery: "body",
    children: "a[href*='res.cloudinary.com']",
    pswpModule: () => import("photoswipe")
  });
  lightbox.init();
};
#+end_src 

Use it on the page that renders `Gallery.astro`:

#+begin_src astro
import Gallery from "@/components/Gallery.astro";
import Lightbox from "@/components/Lightbox.client.ts";
import { getEntry } from "astro:content";

const album = (await getEntry("albums", "tiff-2025")).data;

<Gallery {album} />
<Lightbox client:load />
#+end_src 

*** 6) Nice polish with zero manual work

- *Preconnect* to speed up first paint (put in your `<head>`):

  #+begin_src html
  <link rel="preconnect" href="https://res.cloudinary.com">
  #+end_src 

- *LQIP/blur previews* (optional): add a second named transform `t_blur` with `e_blur:2000,w_20` and use it as a CSS background until the image loads (purely optional).
- *Uniform look*: If you want consistent crops, set `ar_4:3` (or your favorite) inside `t_gallery`. The smart gravity will still find the subject within that frame.

*** 7) Free-tier reality check

For a solo portfolio with modest traffic, Cloudinary's free plan is typically plenty. If a post blows up, you can either upgrade for that month or flip on *eager transformations* for your common sizes to cache ahead of time.

If you want, I can:

- Add a *tag index page* (e.g., `/albums/tag/red-carpet`) driven by Content Collections.
- Swap CSS columns for *native masonry* when you're targeting browsers that support it.
- Wire up a *"like" counter* later using Supabase --- but your images and polish can stay on Cloudinary exactly as above.


** Dual System Design

*** Main Landing Page (Highlights)
- *Location*: `/` (index.astro)
- *Photo Source*: `public/highlights/`
- *Purpose*: Showcase best photos in beautiful masonry layout
- *Features*: 
  - True masonry with varied photo sizes (wide, tall, small, medium)
  - CSS Grid with 10px gaps
  - Downloaded directly from live photos.jaydixit.com
  - Exact visual match to original site

*** Gallery System
- *Location*: `/gallery/[...folder]` (dynamic routes)
- *Photo Source*: `public/photos/**` (nested folder structure)
- *Purpose*: Organized collections by theme/event/category
- *Features*:
  - Folder-based automatic gallery generation
  - Search and tag filtering
  - Photo captions and metadata
  - Like buttons and comments

** Technology Stack

| Component       | Technology           | Purpose                        |
|-----------------+----------------------+--------------------------------|
| Site Generator  | Astro v5.13.2        | Static site generation         |
| Layout System   | CSS Grid Masonry     | Varied photo sizes and spacing |
| Image Viewer    | GLightbox v3.3.1     | Full-screen lightbox viewing   |
| Styling         | Tailwind CSS v4.0.14 | Responsive design system       |
| Build Tool      | Vite                 | Fast development and building  |
| Package Manager | npm                  | Dependency management          |
| Hosting Target  | Vercel               | Static site deployment         |
| Domain          | photos.jaydixit.com  | Custom domain                  |

* Implementation Details

** Masonry Layout System

*** Main Page Masonry
- *Method*: CSS Grid with `grid-auto-rows: 10px`
- *Size Variations*:
  - Small: `grid-row-end: span 20` (1 column × 20 rows)
  - Medium: `grid-row-end: span 30` (1 column × 30 rows)
  - Tall: `grid-row-end: span 45` (1 column × 45 rows)
  - Wide: `grid-row-end: span 25, grid-column-end: span 2` (2 columns × 25 rows)
  - Wide-short: `grid-row-end: span 20, grid-column-end: span 2` (2 columns × 20 rows)
  - Wide-tall: `grid-row-end: span 40, grid-column-end: span 2` (2 columns × 40 rows)

*** Size Distribution Algorithm
#+BEGIN_SRC javascript
const sizeClass = index % 7 === 0 ? 'wide-tall' : 
                 index % 5 === 0 ? 'wide-short' : 
                 index % 4 === 1 ? 'tall' : 
                 index % 6 === 2 ? 'wide' : 
                 index % 8 === 3 ? 'small' : 'medium';
#+END_SRC

*** Responsive Breakpoints
- Mobile: 2 columns (`grid-template-columns: repeat(auto-fit, minmax(200px, 1fr))`)
- Tablet (640px+): 3 columns (`minmax(180px, 1fr)`)
- Desktop (1024px+): 4 columns (`minmax(200px, 1fr)`)
- Large (1280px+): 5 columns

** Photo Organization System

*** Folder Structure
#+BEGIN_EXAMPLE
public/
├── highlights/           # Main page masonry photos
│   ├── vanessa-kirby.jpg
│   ├── conan.jpg
│   └── ...
└── photos/              # Gallery system
    ├── red-carpet/
    │   ├── tiff/
    │   │   ├── vanessa-kirby_tiff_2024.jpg
    │   │   └── tags.json
    │   └── sundance/
    │       └── conan-obrien_sundance_2024.jpg
    ├── portraits/
    │   └── studio/
    │       └── jeremy-strong_studio-session_2024.jpg
    ├── events/
    │   └── nobel/
    │       └── john-hopfield_nobel-physics_2024.jpg
    └── themes/
        └── fashion/
            └── judd-apatow_fashion-shoot_2024.jpg
#+END_EXAMPLE

*** Filename Convention
- *Pattern*: `subject_event_year.jpg`
- *Example*: `maria-bakalova_locarno_2024.jpg`
- *Generated Caption*: "Maria Bakalova at Locarno in 2024"
- *Tag Extraction*: `[maria, bakalova, locarno, 2024]`

** Search and Filtering System

*** Search Implementation
- *Method*: JavaScript real-time filtering
- *Targets*: Photo captions, subject names, event names, tags
- *Algorithm*: Case-insensitive substring matching
#+BEGIN_SRC javascript
const matchesSearch = !searchTerm || caption.includes(searchTerm);
#+END_SRC

*** Tag System
- *Sources*:
  1. Filename parsing (automatic)
  2. `tags.json` override files (manual)
  3. Folder name inheritance
- *Filtering Logic*: AND operation (all selected tags must match)
#+BEGIN_SRC javascript
const matchesTags = activeTags.size === 0 || 
  [...activeTags].every(tag => tags.includes(tag));
#+END_SRC

** Interactive Features

*** Like System
- *Storage*: localStorage (demo) → Supabase (production ready)
- *Data Structure*: `{photoId: {count: number, liked: boolean}}`
- *UI*: Heart icon with count, animated on interaction
- *Method*: Event delegation with data attributes

*** Comments System
- *Technology*: Giscus (GitHub Discussions)
- *Scope*: Per-gallery threads
- *Integration*: PhotoComments.astro component
- *Configuration*: Ready for `incandescentman/jaydixit-photos` repo

** Routing System

*** Static Routes
- `/` → Main highlights masonry
- `/gallery` → Gallery index (categorized view)
- `/about` → About page
- `/collections` → Legacy collection system

*** Dynamic Routes
- `/gallery/[...folder]` → Nested gallery pages
- *Examples*:
  - `/gallery/red-carpet/tiff`
  - `/gallery/portraits/studio`
  - `/gallery/events/nobel`

*** Route Generation
- *Method*: `getStaticPaths()` with recursive folder scanning
- *Source*: `public/photos/**` directory structure
- *Filter*: Only folders containing image files

** Navigation System

*** Header Navigation
- *Brand*: "Jay Dixit Photos"
- *Menu Items*:
  - Red Carpet Photos → `/gallery`
  - About → `/about`
  - Contact → `mailto:jay@jaydixit.com`
  - jaydixit.com → External link
- *Social Links*: Twitter (𝕏), LinkedIn, Instagram

*** Gallery Index Organization
- *Grouping*: By top-level folder (category)
- *Display*: Grid cards with thumbnails
- *Metadata*: Photo count per gallery
- *Thumbnail*: First image from each gallery

** Performance Optimizations

*** Image Handling
- *Loading*: Lazy loading with `loading="lazy"`
- *Format*: Original high-quality JPEG
- *Sizing*: `object-fit: cover` for consistent grid
- *Optimization*: Astro's built-in image optimization

*** Asset Management
- *GLightbox*: CDN-loaded lightbox library
- *Tailwind*: JIT compilation for minimal CSS
- *JavaScript*: Minimal client-side code
- *Static Generation*: All routes pre-built

** Developer Experience

*** CLI Tools
- *Tag Generation*: `npm run generate-tags`
  #+BEGIN_EXAMPLE
  node scripts/generate-tags-json.js ./public/photos/red-carpet/tiff
  #+END_EXAMPLE
- *Development*: `npm run dev --open`
- *Build*: `npm run build`
- *Photo Download*: `npm run download-live`

*** Content Management
- *Method*: File system based (no CMS)
- *Workflow*:
  1. Add photos to appropriate `public/photos/category/` folder
  2. Follow naming convention: `subject_event_year.jpg`
  3. Optionally run tag generation script
  4. Deploy (automatic route generation)

*** Maintenance
- *Adding Galleries*: Create new folder in `public/photos/`
- *Updating Photos*: Replace files in folders
- *Customizing Tags*: Edit or create `tags.json` files
- *Managing Highlights*: Update `public/highlights/` folder

* Design Decisions

** Why Dual System?
- *Main Page*: Showcases best work immediately (highlights)
- *Gallery System*: Provides organized browsing by category
- *Flexibility*: Supports both "wow factor" and detailed exploration

** Why CSS Grid Masonry?
- *Performance*: No JavaScript layout calculations
- *Responsive*: Natural breakpoint adaptation
- *Consistency*: Precise 10px spacing control
- *Visual Interest*: Varied sizes prevent monotony

** Why Folder-Based?
- *Simplicity*: No database or CMS complexity
- *Version Control*: Photos tracked in git
- *Scalability*: Easy to add new categories
- *Portability*: No vendor lock-in

** Why Filename Metadata?
- *Self-Contained*: Metadata travels with file
- *Human Readable*: Clear naming convention
- *Automation*: Enables automatic caption generation
- *Flexibility*: Override with `tags.json` when needed

* Implementation Status

** ✅ Completed Features
- *Dual System Architecture*: Main highlights masonry + gallery system
- *Folder-Based Routing*: Dynamic routes from public/photos/** structure  
- *CSS Grid Masonry*: Precise 10px spacing with varied photo sizes
- *Search & Filtering*: Real-time search with clickable tag pills
- *Like System*: localStorage-based with animated interactions
- *Comments Integration*: Giscus components ready for activation
- *Caption Generation*: Automatic parsing from filename convention
- *Tag System*: Filename parsing + tags.json override capability
- *Responsive Design*: Mobile-first with breakpoint optimization
- *Performance*: Lazy loading, efficient CSS Grid, minimal JavaScript

** 🚧 Remaining Implementation Items

*** External Service Integration
- *Supabase Setup*: Replace localStorage likes with persistent database
  - Create Supabase project: `jaydixit-photos`
  - Set up `photo_likes` table with schema
  - Replace localStorage API calls with Supabase client
- *Giscus Configuration*: Connect to GitHub Discussions
  - Enable Discussions on `incandescentman/jaydixit-photos` repo
  - Configure at giscus.app to get repo-id and category-id
  - Update PhotoComments.astro with real configuration values

*** Production Deployment
- *Vercel Setup*: Deploy to photos.jaydixit.com
  - Configure custom domain
  - Set up Git integration for automatic deployments
  - Verify build process and static output

*** Content Population
- *Photo Organization*: Populate gallery folders with real collections
  - `/public/photos/red-carpet/tiff/` - TIFF red carpet photos
  - `/public/photos/red-carpet/sundance/` - Sundance photos
  - `/public/photos/portraits/studio/` - Studio sessions
  - `/public/photos/events/nobel/` - Nobel Prize events
  - `/public/photos/themes/fashion/` - Fashion photography
- *Tag Generation*: Run scripts for all populated folders
- *Testing*: Verify all routes and functionality with real content

** 🔮 Future Enhancements

*** Immediate Possibilities
- *EXIF Data*: Extract camera settings and date information
- *Image Upload UI*: Web-based photo management interface
- *Social Sharing*: Per-photo sharing buttons
- *Individual Photo Pages*: Dedicated URLs for each photo

*** Long-term Considerations
- *Search Enhancement*: Full-text search with indexing
- *Performance*: Advanced image optimization and CDN integration
- *Analytics*: Photo view tracking and popularity metrics
- *Workflow*: Automated photo processing pipeline
- *CMS Integration*: Optional admin interface for non-technical users

* Deployment

** Current Setup
- *Development*: `http://localhost:4323/`
- *Build Target*: Static files in `dist/`
- *Deployment*: Vercel Git integration
- *Domain*: photos.jaydixit.com

** Configuration
- *Astro Config*: Static output mode
- *Base URL*: Root deployment (no subdirectory)
- *Asset Handling*: Public folder serving
- *Build*: Node.js environment

This architecture provides a robust, maintainable, and visually appealing photography portfolio that balances automation with flexibility, performance with features, and simplicity with sophistication.

